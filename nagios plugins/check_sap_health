#! /usr/bin/perl -w
# nagios: +epn

package GLPlugin;
use strict;
use IO::File;
use File::Basename;
use Digest::MD5 qw(md5_hex);
use Errno;
use AutoLoader;
our $AUTOLOAD;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $pluginname = basename($ENV{'NAGIOS_PLUGIN'} || $0);
  our $blacklist = undef;
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $variables = {};
}

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {};
  bless $self, $class;
  $GLPlugin::plugin = GLPlugin::Commandline->new(%params);
  return $self;
}

sub init {
  my $self = shift;
  if ($self->opts->can("blacklist") && $self->opts->blacklist &&
      -f $self->opts->blacklist) {
    $self->opts->blacklist = do {
        local (@ARGV, $/) = $self->opts->blacklist; <> };
  }
}

sub dumper {
  my $self = shift;
  my $object = shift;
  my $run = $object->{runtime};
  delete $object->{runtime};
  printf STDERR "%s\n", Data::Dumper::Dumper($object);
  $object->{runtime} = $run;
}

sub no_such_mode {
  my $self = shift;
  printf "Mode %s is not implemented for this type of device\n",
      $self->opts->mode;
  exit 3;
}

#########################################################
# framework-related. setup, options
#
sub add_modes {
  my $self = shift;
  my $modes = shift;
  my $modestring = "";
  my @modes = @{$modes};
  my $longest = length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0]);
  my $format = "       %-".
      (length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0])).
      "s\t(%s)\n";
  foreach (@modes) {
    $modestring .= sprintf $format, $_->[1], $_->[3];
  }
  $modestring .= sprintf "\n";
  $GLPlugin::plugin->{modestring} = $modestring;
}

sub add_arg {
  my $self = shift;
  my %args = @_;
  if ($args{help} =~ /^--mode/) {
    $args{help} .= "\n".$GLPlugin::plugin->{modestring};
  }
  $GLPlugin::plugin->{opts}->add_arg(%args);
}

sub add_mode {
  my $self = shift;
  my %args = @_;
  push(@{$GLPlugin::plugin->{modes}}, \%args);
  my $longest = length ((reverse sort {length $a <=> length $b} map { $_->{spec} } @{$GLPlugin::plugin->{modes}})[0]);
  my $format = "       %-".
      (length ((reverse sort {length $a <=> length $b} map { $_->{spec} } @{$GLPlugin::plugin->{modes}})[0])).
      "s\t(%s)\n";
  $GLPlugin::plugin->{modestring} = "";
  foreach (@{$GLPlugin::plugin->{modes}}) {
    $GLPlugin::plugin->{modestring} .= sprintf $format, $_->{spec}, $_->{help};
  }
  $GLPlugin::plugin->{modestring} .= "\n";
}

sub validate_args {
  my $self = shift;
  if ($self->opts->mode =~ /^my-([^\-.]+)/) {
    my $param = $self->opts->mode;
    $param =~ s/\-/::/g;
    $self->add_mode(
        internal => $param,
        spec => $self->opts->mode,
        alias => undef,
        help => 'my extension',
    );
  } elsif ($self->opts->mode eq 'encode') {
    my $input = <>;
    chomp $input;
    $input =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
    printf "%s\n", $input;
    exit 0;
  } elsif ((! grep { $self->opts->mode eq $_ } map { $_->{spec} } @{$GLPlugin::plugin->{modes}}) &&
      (! grep { $self->opts->mode eq $_ } map { defined $_->{alias} ? @{$_->{alias}} : () } @{$GLPlugin::plugin->{modes}})) {
    printf "UNKNOWN - mode %s\n", $self->opts->mode;
    $self->opts->print_help();
    exit 3;
  }
  if ($self->opts->name && $self->opts->name =~ /(%22)|(%27)/) {
    my $name = $self->opts->name;
    $name =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
    $self->override_opt('name', $name);
  }
  $GLPlugin::mode = (
      map { $_->{internal} }
      grep {
         ($self->opts->mode eq $_->{spec}) ||
         ( defined $_->{alias} && grep { $self->opts->mode eq $_ } @{$_->{alias}})
      } @{$GLPlugin::plugin->{modes}}
  )[0];
  if ($self->opts->multiline) {
    $ENV{NRPE_MULTILINESUPPORT} = 1;
  } else {
    $ENV{NRPE_MULTILINESUPPORT} = 0;
  }
  if (! $self->opts->statefilesdir) {
    if ($^O =~ /MSWin/) {
      if (defined $ENV{TEMP}) {
        $self->override_opt('statefilesdir', $ENV{TEMP}."/".$GLPlugin::plugin->{name});
      } elsif (defined $ENV{TMP}) {
        $self->override_opt('statefilesdir', $ENV{TMP}."/".$GLPlugin::plugin->{name});
      } elsif (defined $ENV{windir}) {
        $self->override_opt('statefilesdir', File::Spec->catfile($ENV{windir}, 'Temp')."/".$GLPlugin::plugin->{name});
      } else {
        $self->override_opt('statefilesdir', "C:/".$GLPlugin::plugin->{name});
      }
    } elsif (exists $ENV{OMD_ROOT}) {
      $self->override_opt('statefilesdir', $ENV{OMD_ROOT}."/var/tmp/".$GLPlugin::plugin->{name});
    } else {
      $self->override_opt('statefilesdir', "/var/tmp/".$GLPlugin::plugin->{name});
    }
  }
  $GLPlugin::plugin->{statefilesdir} = $self->opts->statefilesdir;
  if ($self->opts->can("warningx") && $self->opts->warningx) {
    foreach my $key (keys %{$self->opts->warningx}) {
      $self->set_thresholds(metric => $key, 
          warning => $self->opts->warningx->{$key});
    }
  }
  if ($self->opts->can("criticalx") && $self->opts->criticalx) {
    foreach my $key (keys %{$self->opts->criticalx}) {
      $self->set_thresholds(metric => $key, 
          critical => $self->opts->criticalx->{$key});
    }
  }
  $self->set_timeout_alarm() if ! $SIG{'ALRM'};
}

sub set_timeout_alarm {
  my $self = shift;
  $SIG{'ALRM'} = sub {
    printf "UNKNOWN - %s timed out after %d seconds\n",
        $GLPlugin::plugin->{name}, $self->opts->timeout;
    exit 3;
  };
  alarm($self->opts->timeout);
}

#########################################################
# global helpers
#
sub set_variable {
  my $self = shift;
  my $key = shift;
  my $value = shift;
  $GLPlugin::variables->{$key} = $value;
}

sub get_variable {
  my $self = shift;
  my $key = shift;
  my $fallback = shift;
  return exists $GLPlugin::variables->{$key} ?
      $GLPlugin::variables->{$key} : $fallback;
}

sub debug {
  my $self = shift;
  my $format = shift;
  my $tracefile = "/tmp/".$GLPlugin::pluginname.".trace";
  $self->{trace} = -f $tracefile ? 1 : 0;
  if ($self->get_variable("verbose") &&
      $self->get_variable("verbose") > $self->get_variable("verbosity", 10)) {
    printf("%s: ", scalar localtime);
    printf($format, @_);
    printf "\n";
  }
  if ($self->{trace}) {
    my $logfh = new IO::File;
    $logfh->autoflush(1);
    if ($logfh->open($tracefile, "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @_);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub filter_namex {
  my $self = shift;
  my $opt = shift;
  my $name = shift;
  if ($opt) {
    if ($self->opts->regexp) {
      if ($name =~ /$opt/i) {
        return 1;
      }
    } else {
      if (lc $opt eq lc $name) {
        return 1;
      }
    }
  } else {
    return 1;
  }
  return 0;
}

sub filter_name {
  my $self = shift;
  my $name = shift;
  return $self->filter_namex($self->opts->name, $name);
}

sub filter_name2 {
  my $self = shift;
  my $name = shift;
  return $self->filter_namex($self->opts->name2, $name);
}

sub filter_name3 {
  my $self = shift;
  my $name = shift;
  return $self->filter_namex($self->opts->name3, $name);
}

sub version_is_minimum {
  my $self = shift;
  my $version = shift;
  my $installed_version;
  my $newer = 1;
  if ($self->get_variable("version")) {
    $installed_version = $self->get_variable("version");
  } elsif (exists $self->{version}) {
    $installed_version = $self->{version};
  } else {
    return 0;
  }
  my @v1 = map { $_ eq "x" ? 0 : $_ } split(/\./, $version);
  my @v2 = split(/\./, $installed_version);
  if (scalar(@v1) > scalar(@v2)) {
    push(@v2, (0) x (scalar(@v1) - scalar(@v2)));
  } elsif (scalar(@v2) > scalar(@v1)) {
    push(@v1, (0) x (scalar(@v2) - scalar(@v1)));
  }
  foreach my $pos (0..$#v1) {
    if ($v2[$pos] > $v1[$pos]) {
      $newer = 1;
      last;
    } elsif ($v2[$pos] < $v1[$pos]) {
      $newer = 0;
      last;
    }
  }
  return $newer;
}

sub accentfree {
  my $self = shift;
  my $text = shift;
  # thanks mycoyne who posted this accent-remove-algorithm
  # http://www.experts-exchange.com/Programming/Languages/Scripting/Perl/Q_23275533.html#a21234612
  my @transformed;
  my %replace = (
    '9a' => 's', '9c' => 'oe', '9e' => 'z', '9f' => 'Y', 'c0' => 'A', 'c1' => 'A',
    'c2' => 'A', 'c3' => 'A', 'c4' => 'A', 'c5' => 'A', 'c6' => 'AE', 'c7' => 'C',
    'c8' => 'E', 'c9' => 'E', 'ca' => 'E', 'cb' => 'E', 'cc' => 'I', 'cd' => 'I',
    'ce' => 'I', 'cf' => 'I', 'd0' => 'D', 'd1' => 'N', 'd2' => 'O', 'd3' => 'O',
    'd4' => 'O', 'd5' => 'O', 'd6' => 'O', 'd8' => 'O', 'd9' => 'U', 'da' => 'U',
    'db' => 'U', 'dc' => 'U', 'dd' => 'Y', 'e0' => 'a', 'e1' => 'a', 'e2' => 'a',
    'e3' => 'a', 'e4' => 'a', 'e5' => 'a', 'e6' => 'ae', 'e7' => 'c', 'e8' => 'e',
    'e9' => 'e', 'ea' => 'e', 'eb' => 'e', 'ec' => 'i', 'ed' => 'i', 'ee' => 'i',
    'ef' => 'i', 'f0' => 'o', 'f1' => 'n', 'f2' => 'o', 'f3' => 'o', 'f4' => 'o',
    'f5' => 'o', 'f6' => 'o', 'f8' => 'o', 'f9' => 'u', 'fa' => 'u', 'fb' => 'u',
    'fc' => 'u', 'fd' => 'y', 'ff' => 'y',
  );
  my @letters = split //, $text;;
  for (my $i = 0; $i <= $#letters; $i++) {
    my $hex = sprintf "%x", ord($letters[$i]);
    $letters[$i] = $replace{$hex} if (exists $replace{$hex});
  }
  push @transformed, @letters;
  return join '', @transformed;
}

sub dump {
  my $self = shift;
  my $class = ref($self);
  $class =~ s/^.*:://;
  if (exists $self->{flat_indices}) {
    printf "[%s_%s]\n", uc $class, $self->{flat_indices};
  } else {
    printf "[%s]\n", uc $class;
  }
  foreach (grep !/^(info|trace|warning|critical|blacklisted|extendedinfo|flat_indices|indices)/, sort keys %{$self}) {
    printf "%s: %s\n", $_, $self->{$_} if defined $self->{$_} && ref($self->{$_}) ne "ARRAY";
  }
  if ($self->{info}) {
    printf "info: %s\n", $self->{info};
  }
  printf "\n";
  foreach (grep !/^(info|trace|warning|critical|blacklisted|extendedinfo|flat_indices|indices)/, sort keys %{$self}) {
    if (defined $self->{$_} && ref($self->{$_}) eq "ARRAY") {
      my $have_flat_indices = 1;
      foreach my $obj (@{$self->{$_}}) {
        $have_flat_indices = 0 if (! exists $obj->{flat_indices});
      }
      if ($have_flat_indices) {
        foreach my $obj (sort {
            join('', map { sprintf("%30d",$_) } split( /\./, $a->{flat_indices})) cmp
            join('', map { sprintf("%30d",$_) } split( /\./, $b->{flat_indices}))
        } @{$self->{$_}}) {
          $obj->dump();
        }
      } else {
        foreach my $obj (@{$self->{$_}}) {
          $obj->dump();
        }
      }
    }
  }
}

sub table_ascii {
  my $self = shift;
  my $table = shift;
  my $titles = shift;
  my $text = "";
  my $column_length = {};
  my $column = 0;
  foreach (@{$titles}) {
    $column_length->{$column++} = length($_);
  }
  foreach my $tr (@{$table}) {
    @{$tr} = map { ref($_) eq "ARRAY" ? $_->[0] : $_; } @{$tr};
    $column = 0;
    foreach my $td (@{$tr}) {
      if (length($td) > $column_length->{$column}) {
        $column_length->{$column} = length($td);
      }
      $column++;
    }
  }
  $column = 0;
  foreach (@{$titles}) {
    $column_length->{$column} = "%".($column_length->{$column} + 3)."s";
    $column++;
  }
  $column = 0;
  foreach (@{$titles}) {
    $text .= sprintf $column_length->{$column++}, $_;
  }
  $text .= "\n";
  foreach my $tr (@{$table}) {
    $column = 0;
    foreach my $td (@{$tr}) {
      $text .= sprintf $column_length->{$column++}, $td;
    }
    $text .= "\n";
  }
  return $text;
}

sub table_html {
  my $self = shift;
  my $table = shift;
  my $titles = shift;
  my $text = "";
  $text .= "<table style=\"border-collapse:collapse; border: 1px solid black;\">";
  $text .= "<tr>";
  foreach (@{$titles}) {
    $text .= sprintf "<th style=\"text-align: left; padding-left: 4px; padding-right: 6px;\">%s</th>", $_;
  }
  $text .= "</tr>";
  foreach my $tr (@{$table}) {
    $text .= "<tr>";
    foreach my $td (@{$tr}) {
      my $class = "statusOK";
      if (ref($td) eq "ARRAY") {
        $class = {
          0 => "statusOK",
          1 => "statusWARNING",
          2 => "statusCRITICAL",
          3 => "statusUNKNOWN",
        }->{$td->[1]};
        $td = $td->[0];
      }
      $text .= sprintf "<td style=\"text-align: left; padding-left: 4px; padding-right: 6px;\" class=\"%s\">%s</td>", $class, $td;
    }
    $text .= "</tr>";
  }
  $text .= "</table>";
  return $text;
}

sub load_my_extension {
  my $self = shift;
  if ($self->opts->mode =~ /^my-([^-.]+)/) {
    my $class = $1;
    my $loaderror = undef;
    substr($class, 0, 1) = uc substr($class, 0, 1);
    if (! $self->opts->get("with-mymodules-dyn-dir")) {
      $self->override_opt("with-mymodules-dyn-dir", "");
    }
    my $plugin_name = $GLPlugin::pluginname;
    $plugin_name =~ /check_(.*?)_health/;
    $plugin_name = "Check".uc(substr($1, 0, 1)).substr($1, 1)."Health";
    foreach my $libpath (split(":", $self->opts->get("with-mymodules-dyn-dir"))) {
      foreach my $extmod (glob $libpath."/".$plugin_name."*.pm") {
        my $stderrvar;
        *SAVEERR = *STDERR;
        open OUT ,'>',\$stderrvar;
        *STDERR = *OUT;
        eval {
          $self->debug(sprintf "loading module %s", $extmod);
          require $extmod;
        };
        *STDERR = *SAVEERR;
        if ($@) {
          $loaderror = $extmod;
          $self->debug(sprintf "failed loading module %s: %s", $extmod, $@);
        }
      }
    }
    my $original_class = ref($self);
    my $original_init = $self->can("init");
    bless $self, "My$class";
    if ($self->isa("GLPlugin")) {
      my $new_init = $self->can("init");
      if ($new_init == $original_init) {
          $self->add_unknown(
              sprintf "Class %s needs an init() method", ref($self));
      } else {
        # now go back to check_*_health.pl where init() will be called
      }
    } else {
      bless $self, $original_class;
      $self->add_unknown(
          sprintf "Class %s is not a subclass of GLPlugin%s",
              "My$class",
              $loaderror ? sprintf " (syntax error in %s?)", $loaderror : "" );
      my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
      $self->nagios_exit($code, $message);
    }
  }
}

sub decode_password {
  my $self = shift;
  my $password = shift;
  if ($password && $password =~ /^rfc3986:\/\/(.*)/) {
    $password =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
  }
  return $password;
}


#########################################################
# runtime methods
#
sub mode : lvalue {
  my $self = shift;
  $GLPlugin::mode;
}

sub statefilesdir {
  my $self = shift;
  return $GLPlugin::plugin->{statefilesdir};
}

sub opts { # die beiden _nicht_ in AUTOLOAD schieben, das kracht!
  my $self = shift;
  return $GLPlugin::plugin->opts();
}

sub getopts {
  my $self = shift;
  my $envparams = shift || [];
  $GLPlugin::plugin->getopts();
  # es kann sein, dass beim aufraeumen zum schluss als erstes objekt
  # das $GLPlugin::plugin geloescht wird. in anderen destruktoren
  # (insb. fuer dbi disconnect) steht dann $self->opts->verbose
  # nicht mehr zur verfuegung bzw. $GLPlugin::plugin->opts ist undef.
  $self->set_variable("verbose", $self->opts->verbose);
  #
  # die gueltigkeit von modes wird bereits hier geprueft und nicht danach
  # in validate_args. (zwischen getopts und validate_args wird
  # normalerweise classify aufgerufen, welches bereits eine verbindung
  # zum endgeraet herstellt. bei falschem mode waere das eine verschwendung
  # bzw. durch den exit3 ein evt. unsauberes beenden der verbindung.
  if ((! grep { $self->opts->mode eq $_ } map { $_->{spec} } @{$GLPlugin::plugin->{modes}}) &&
      (! grep { $self->opts->mode eq $_ } map { defined $_->{alias} ? @{$_->{alias}} : () } @{$GLPlugin::plugin->{modes}})) {
    if ($self->opts->mode !~ /^my-/) {
      printf "UNKNOWN - mode %s\n", $self->opts->mode;
      $self->opts->print_help();
      exit 3;
    }
  }
}

sub add_ok {
  my $self = shift;
  my $message = shift || $self->{info};
  $self->add_message(OK, $message);
}

sub add_warning {
  my $self = shift;
  my $message = shift || $self->{info};
  $self->add_message(WARNING, $message);
}

sub add_critical {
  my $self = shift;
  my $message = shift || $self->{info};
  $self->add_message(CRITICAL, $message);
}

sub add_unknown {
  my $self = shift;
  my $message = shift || $self->{info};
  $self->add_message(UNKNOWN, $message);
}

sub add_message {
  my $self = shift;
  my $level = shift;
  my $message = shift || $self->{info};
  $GLPlugin::plugin->add_message($level, $message)
      unless $self->is_blacklisted();
  if (exists $self->{failed}) {
    if ($level == UNKNOWN && $self->{failed} == OK) {
      $self->{failed} = $level;
    } elsif ($level > $self->{failed}) {
      $self->{failed} = $level;
    }
  }
}

sub clear_ok {
  my $self = shift;
  $self->clear_messages(OK);
}

sub clear_warning {
  my $self = shift;
  $self->clear_messages(WARNING);
}

sub clear_critical {
  my $self = shift;
  $self->clear_messages(CRITICAL);
}

sub clear_unknown {
  my $self = shift;
  $self->clear_messages(UNKNOWN);
}

sub clear_all { # deprecated, use clear_messages
  my $self = shift;
  $self->clear_ok();
  $self->clear_warning();
  $self->clear_critical();
  $self->clear_unknown();
}

sub set_level {
  my $self = shift;
  my $code = shift;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  if (! exists $self->{tmp_level}) {
    $self->{tmp_level} = {
      ok => 0,
      warning => 0,
      critical => 0,
      unknown => 0,
    };
  }
  $self->{tmp_level}->{$code}++;
}

sub get_level {
  my $self = shift;
  return OK if ! exists $self->{tmp_level};
  my $code = OK;
  $code ||= CRITICAL if $self->{tmp_level}->{critical};
  $code ||= WARNING  if $self->{tmp_level}->{warning};
  $code ||= UNKNOWN  if $self->{tmp_level}->{unknown};
  return $code;
}

#########################################################
# blacklisting
#
sub blacklist {
  my $self = shift;
  $self->{blacklisted} = 1;
}

sub add_blacklist {
  my $self = shift;
  my $list = shift;
  $GLPlugin::blacklist = join('/',
      (split('/', $self->opts->blacklist), $list));
}

sub is_blacklisted {
  my $self = shift;
  if (! $self->opts->can("blacklist")) {
    return 0;
  }
  if (! exists $self->{blacklisted}) {
    $self->{blacklisted} = 0;
  }
  if (exists $self->{blacklisted} && $self->{blacklisted}) {
    return $self->{blacklisted};
  }
  # FAN:459,203/TEMP:102229/ENVSUBSYSTEM
  # FAN_459,FAN_203,TEMP_102229,ENVSUBSYSTEM
  if ($self->opts->blacklist =~ /_/) {
    foreach my $bl_item (split(/,/, $self->opts->blacklist)) {
      if ($bl_item eq $self->internal_name()) {
        $self->{blacklisted} = 1;
      }
    }
  } else {
    foreach my $bl_items (split(/\//, $self->opts->blacklist)) {
      if ($bl_items =~ /^(\w+):([\:\d\-,]+)$/) {
        my $bl_type = $1;
        my $bl_names = $2;
        foreach my $bl_name (split(/,/, $bl_names)) {
          if ($bl_type."_".$bl_name eq $self->internal_name()) {
            $self->{blacklisted} = 1;
          }
        }
      } elsif ($bl_items =~ /^(\w+)$/) {
        if ($bl_items eq $self->internal_name()) {
          $self->{blacklisted} = 1;
        }
      }
    }
  } 
  return $self->{blacklisted};
}

#########################################################
# additional info
#
sub add_info {
  my $self = shift;
  my $info = shift;
  $info = $self->is_blacklisted() ? $info.' (blacklisted)' : $info;
  $self->{info} = $info;
  push(@{$GLPlugin::info}, $info);
}

sub annotate_info {
  my $self = shift;
  my $annotation = shift;
  my $lastinfo = pop(@{$GLPlugin::info});
  $lastinfo .= sprintf ' (%s)', $annotation;
  $self->{info} = $lastinfo;
  push(@{$GLPlugin::info}, $lastinfo);
}

sub add_extendedinfo {  # deprecated
  my $self = shift;
  my $info = shift;
  $self->{extendedinfo} = $info;
  return if ! $self->opts->extendedinfo;
  push(@{$GLPlugin::extendedinfo}, $info);
}

sub get_info {
  my $self = shift;
  my $separator = shift || ' ';
  return join($separator , @{$GLPlugin::info});
}

sub get_last_info {
  my $self = shift;
  return pop(@{$GLPlugin::info});
}

sub get_extendedinfo {
  my $self = shift;
  my $separator = shift || ' ';
  return join($separator, @{$GLPlugin::extendedinfo});
}

sub add_summary {  # deprecated
  my $self = shift;
  my $summary = shift;
  push(@{$GLPlugin::summary}, $summary);
}

sub get_summary {
  my $self = shift;
  return join(', ', @{$GLPlugin::summary});
}

#########################################################
# persistency
#
sub valdiff {
  my $self = shift;
  my $pparams = shift;
  my %params = %{$pparams};
  my @keys = @_;
  my $now = time;
  my $newest_history_set = {};
  my $last_values = $self->load_state(%params) || eval {
    my $empty_events = {};
    foreach (@keys) {
      if (ref($self->{$_}) eq "ARRAY") {
        $empty_events->{$_} = [];
      } else {
        $empty_events->{$_} = 0;
      }
    }
    $empty_events->{timestamp} = 0;
    if ($self->opts->lookback) {
      $empty_events->{lookback_history} = {};
    }
    $empty_events;
  };
  $self->{'delta_timestamp'} = $now - $last_values->{timestamp};
  foreach (@keys) {
    if ($self->opts->lookback) {
      # find a last_value in the history which fits lookback best
      # and overwrite $last_values->{$_} with historic data
      if (exists $last_values->{lookback_history}->{$_}) {
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
            $newest_history_set->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $newest_history_set->{timestamp} = $date;
        }
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
          if ($date >= ($now - $self->opts->lookback)) {
            $last_values->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $last_values->{timestamp} = $date;
            last;
          } else {
            delete $last_values->{lookback_history}->{$_}->{$date};
          }
        }
      }
    }
    if ($self->{$_} =~ /^\d+$/) {
      $last_values->{$_} = 0 if ! exists $last_values->{$_};
      if ($self->{$_} >= $last_values->{$_}) {
        $self->{'delta_'.$_} = $self->{$_} - $last_values->{$_};
      } else {
        # vermutlich db restart und zaehler alle auf null
        $self->{'delta_'.$_} = $self->{$_};
      }
      $self->debug(sprintf "delta_%s %f", $_, $self->{'delta_'.$_});
      $self->{$_.'_per_sec'} = $self->{'delta_timestamp'} ?
          $self->{'delta_'.$_} / $self->{'delta_timestamp'} : 0;
    } elsif (ref($self->{$_}) eq "ARRAY") {
      if ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && exists $params{lastarray}) {
        # innerhalb der lookback-zeit wurde nichts in der lookback_history
        # gefunden. allenfalls irgendwas aelteres. normalerweise
        # wuerde jetzt das array als [] initialisiert.
        # d.h. es wuerde ein delta geben, @found s.u.
        # wenn man das nicht will, sondern einfach aktuelles array mit
        # dem array des letzten laufs vergleichen will, setzt man lastarray
        $last_values->{$_} = %{$newest_history_set} ?
            $newest_history_set->{$_} : []
      } elsif ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && ! exists $params{lastarray}) {
        $last_values->{$_} = [] if ! exists $last_values->{$_};
      } elsif (exists $last_values->{$_} && ! defined $last_values->{$_}) {
        # $_ kann es auch ausserhalb des lookback_history-keys als normalen
        # key geben. der zeigt normalerweise auf den entspr. letzten
        # lookback_history eintrag. wurde der wegen ueberalterung abgeschnitten
        # ist der hier auch undef.
        $last_values->{$_} = %{$newest_history_set} ?
            $newest_history_set->{$_} : []
      }
      my %saved = map { $_ => 1 } @{$last_values->{$_}};
      my %current = map { $_ => 1 } @{$self->{$_}};
      my @found = grep(!defined $saved{$_}, @{$self->{$_}});
      my @lost = grep(!defined $current{$_}, @{$last_values->{$_}});
      $self->{'delta_found_'.$_} = \@found;
      $self->{'delta_lost_'.$_} = \@lost;
    }
  }
  $params{save} = eval {
    my $empty_events = {};
    foreach (@keys) {
      $empty_events->{$_} = $self->{$_};
    }
    $empty_events->{timestamp} = $now;
    if ($self->opts->lookback) {
      $empty_events->{lookback_history} = $last_values->{lookback_history};
      foreach (@keys) {
        $empty_events->{lookback_history}->{$_}->{$now} = $self->{$_};
      }
    }
    $empty_events;
  };
  $self->save_state(%params);
}

sub create_statefilesdir {
  my $self = shift;
  if (! -d $self->statefilesdir()) {
    eval {
      use File::Path;
      mkpath $self->statefilesdir();
    };
    if ($@ || ! -w $self->statefilesdir()) {
      $self->add_message(UNKNOWN,
        sprintf "cannot create status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $self->statefilesdir());
    }
  } elsif (! -w $self->statefilesdir()) {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $self->statefilesdir());
  }
}

sub create_statefile {
  my $self = shift;
  my %params = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s%s", $self->statefilesdir(),
      $self->opts->mode, lc $extension;
}

sub schimpf {
  my $self = shift;
  printf "statefilesdir %s is not writable.\nYou didn't run this plugin as root, didn't you?\n", $self->statefilesdir();
}

# $self->protect_value('1.1-flat_index', 'cpu_busy', 'percent');
sub protect_value {
  my $self = shift;
  my $ident = shift;
  my $key = shift;
  my $validfunc = shift;
  if (ref($validfunc) ne "CODE" && $validfunc eq "percent") {
    $validfunc = sub {
      my $value = shift;
      return ($value < 0 || $value > 100) ? 0 : 1;
    };
  } elsif (ref($validfunc) ne "CODE" && $validfunc eq "positive") {
    $validfunc = sub {
      my $value = shift;
      return ($value < 0) ? 0 : 1;
    };
  }
  if (&$validfunc($self->{$key})) {
    $self->save_state(name => 'protect_'.$ident.'_'.$key, save => {
        $key => $self->{$key},
        exception => 0,
    });
  } else {
    # if the device gives us an clearly wrong value, simply use the last value.
    my $laststate = $self->load_state(name => 'protect_'.$ident.'_'.$key);
    $self->debug(sprintf "self->{%s} is %s and invalid for the %dth time",
        $key, $self->{$key}, $laststate->{exception} + 1);
    if ($laststate->{exception} <= 5) {
      # but only 5 times.
      # if the error persists, somebody has to check the device.
      $self->{$key} = $laststate->{$key};
    }
    $self->save_state(name => 'protect_'.$ident.'_'.$key, save => {
        $key => $laststate->{$key},
        exception => $laststate->{exception}++,
    });
  }
}

sub save_state {
  my $self = shift;
  my %params = @_;
  $self->create_statefilesdir();
  my $statefile = $self->create_statefile(%params);
  my $tmpfile = $self->statefilesdir().'/check__health_tmp_'.$$;
  if ((ref($params{save}) eq "HASH") && exists $params{save}->{timestamp}) {
    $params{save}->{localtime} = scalar localtime $params{save}->{timestamp};
  }
  my $seekfh = new IO::File;
  if ($seekfh->open($tmpfile, "w")) {
    $seekfh->printf("%s", Data::Dumper::Dumper($params{save}));
    $seekfh->flush();
    $seekfh->close();
    $self->debug(sprintf "saved %s to %s",
        Data::Dumper::Dumper($params{save}), $statefile);
  }
  if (! rename $tmpfile, $statefile) {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status file %s! check your filesystem (permissions/usage/integrity) and disk devices", $statefile);
  }
}

sub load_state {
  my $self = shift;
  my %params = @_;
  my $statefile = $self->create_statefile(%params);
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    return $VAR1;
  } else {
    return undef;
  }
}

#########################################################
# daemon mode
#
sub check_pidfile {
  my $self = shift;
  my $fh = new IO::File;
  if ($fh->open($self->{pidfile}, "r")) {
    my $pid = $fh->getline();
    $fh->close();
    if (! $pid) {
      $self->debug("Found pidfile %s with no valid pid. Exiting.",
          $self->{pidfile});
      return 0;
    } else {
      $self->debug("Found pidfile %s with pid %d", $self->{pidfile}, $pid);
      kill 0, $pid;
      if ($! == Errno::ESRCH) {
        $self->debug("This pidfile is stale. Writing a new one");
        $self->write_pidfile();
        return 1;
      } else {
        $self->debug("This pidfile is held by a running process. Exiting");
        return 0;
      }
    }
  } else {
    $self->debug("Found no pidfile. Writing a new one");
    $self->write_pidfile();
    return 1;
  }
}

sub write_pidfile {
  my $self = shift;
  if (! -d dirname($self->{pidfile})) {
    eval "require File::Path;";
    if (defined(&File::Path::mkpath)) {
      import File::Path;
      eval { mkpath(dirname($self->{pidfile})); };
    } else {
      my @dirs = ();
      map {
          push @dirs, $_;
          mkdir(join('/', @dirs))
              if join('/', @dirs) && ! -d join('/', @dirs);
      } split(/\//, dirname($self->{pidfile}));
    }
  }
  my $fh = new IO::File;
  $fh->autoflush(1);
  if ($fh->open($self->{pidfile}, "w")) {
    $fh->printf("%s", $$);
    $fh->close();
  } else {
    $self->debug("Could not write pidfile %s", $self->{pidfile});
    die "pid file could not be written";
  }
}

sub AUTOLOAD {
  my $self = shift;
  return if ($AUTOLOAD =~ /DESTROY/);
  $self->debug("AUTOLOAD %s\n", $AUTOLOAD)
        if $self->opts->verbose >= 2;
  if ($AUTOLOAD =~ /^(.*)::analyze_and_check_(.*)_subsystem$/) {
    my $class = $1;
    my $subsystem = $2;
    my $analyze = sprintf "analyze_%s_subsystem", $subsystem;
    my $check = sprintf "check_%s_subsystem", $subsystem;
    my @params = @_;
    if (@params) {
      # analyzer class
      my $subsystem_class = shift @params;
      $self->{components}->{$subsystem.'_subsystem'} = $subsystem_class->new();
      $self->debug(sprintf "\$self->{components}->{%s_subsystem} = %s->new()",
          $subsystem, $subsystem_class);
    } else {
      $self->$analyze();
      $self->debug("call %s()", $analyze);
    }
    $self->$check();
  } elsif ($AUTOLOAD =~ /^(.*)::check_(.*)_subsystem$/) {
    my $class = $1;
    my $subsystem = sprintf "%s_subsystem", $2;
    $self->{components}->{$subsystem}->check();
    $self->{components}->{$subsystem}->dump()
        if $self->opts->verbose >= 2;
  } elsif ($AUTOLOAD =~ /^.*::(status_code|check_messages|nagios_exit|html_string|perfdata_string|selected_perfdata|check_thresholds|get_thresholds|opts)$/) {
    return $GLPlugin::plugin->$1(@_);
  } elsif ($AUTOLOAD =~ /^.*::(clear_messages|suppress_messages|add_html|add_perfdata|override_opt|create_opt|set_thresholds|force_thresholds)$/) {
    $GLPlugin::plugin->$1(@_);
  } else {
    $self->debug("AUTOLOAD: class %s has no method %s\n",
        ref($self), $AUTOLOAD);
  }
}


package GLPlugin::Commandline;
use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3, DEPENDENT => 4 };
our %ERRORS = (
    'OK'        => OK,
    'WARNING'   => WARNING,
    'CRITICAL'  => CRITICAL,
    'UNKNOWN'   => UNKNOWN,
    'DEPENDENT' => DEPENDENT,
);

our %STATUS_TEXT = reverse %ERRORS;


sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
       perfdata => [],
       messages => {
         ok => [],
         warning => [],
         critical => [],
         unknown => [],
       },
       args => [],
       opts => GLPlugin::Commandline::Getopt->new(%params),
       modes => [],
       statefilesdir => undef,
  };
  foreach (qw(shortname usage version url plugin blurb extra
      license timeout)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  $self->{name} = $self->{plugin};
  $GLPlugin::plugin = $self;
}

sub AUTOLOAD {
  my $self = shift;
  return if ($AUTOLOAD =~ /DESTROY/);
  $self->debug("AUTOLOAD %s\n", $AUTOLOAD)
        if $self->{opts}->verbose >= 2;
  if ($AUTOLOAD =~ /^.*::(add_arg|override_opt|create_opt)$/) {
    $self->{opts}->$1(@_);
  }
}

sub DESTROY {
  my $self = shift;
  # ohne dieses DESTROY rennt nagios_exit in obiges AUTOLOAD rein
  # und fliegt aufs Maul, weil {opts} bereits nicht mehr existiert.
  # Unerklaerliches Verhalten.
}

sub debug {
  my $self = shift;
  my $format = shift;
  my $tracefile = "/tmp/".$GLPlugin::pluginname.".trace";
  $self->{trace} = -f $tracefile ? 1 : 0;
  if ($self->opts->verbose && $self->opts->verbose > 10) {
    printf("%s: ", scalar localtime);
    printf($format, @_);
    printf "\n";
  }
  if ($self->{trace}) {
    my $logfh = new IO::File;
    $logfh->autoflush(1);
    if ($logfh->open($tracefile, "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @_);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub opts {
  my $self = shift;
  return $self->{opts};
}

sub getopts {
  my $self = shift;
  $self->opts->getopts();
}

sub add_message {
  my $self = shift;
  my ($code, @messages) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  push @{$self->{messages}->{$code}}, @messages;
}

sub selected_perfdata {
  my $self = shift;
  my $label = shift;
  if ($self->opts->can("selectedperfdata") && $self->opts->selectedperfdata) {
    my $pattern = $self->opts->selectedperfdata;
    return ($label =~ /$pattern/i) ? 1 : 0;
  } else {
    return 1;
  }
}

sub add_perfdata {
  my ($self, %args) = @_;
#printf "add_perfdata %s\n", Data::Dumper::Dumper(\%args);
#printf "add_perfdata %s\n", Data::Dumper::Dumper($self->{thresholds});
#
# wenn warning, critical, dann wird von oben ein expliziter wert mitgegeben
# wenn thresholds
#  wenn label in 
#    warningx $self->{thresholds}->{$label}->{warning} existiert
#  dann nimm $self->{thresholds}->{$label}->{warning}
#  ansonsten thresholds->default->warning
#

  my $label = $args{label};
  my $value = $args{value};
  my $uom = $args{uom} || "";
  my $format = '%d';

  if ($self->opts->can("morphperfdata") && $self->opts->morphperfdata) {
    # 'Intel [R] Interface (\d+) usage'='nic$1'
    foreach my $key (keys %{$self->opts->morphperfdata}) {
      if ($label =~ /$key/) {
        my $replacement = '"'.$self->opts->morphperfdata->{$key}.'"';
        my $oldlabel = $label;
        $label =~ s/$key/$replacement/ee;
        if (exists $self->{thresholds}->{$oldlabel}) {
          %{$self->{thresholds}->{$label}} = %{$self->{thresholds}->{$oldlabel}};
        }
      }
    }
  }
  if ($value =~ /\./) {
    if (defined $args{places}) {
      $value = sprintf '%.'.$args{places}.'f', $value;
    } else {
      $value = sprintf "%.2f", $value;
    }
  } else {
    $value = sprintf "%d", $value;
  }
  my $warn = "";
  my $crit = "";
  my $min = defined $args{min} ? $args{min} : "";
  my $max = defined $args{max} ? $args{max} : "";
  if ($args{thresholds} || (! exists $args{warning} && ! exists $args{critical})) {
    if (exists $self->{thresholds}->{$label}->{warning}) {
      $warn = $self->{thresholds}->{$label}->{warning};
    } elsif (exists $self->{thresholds}->{default}->{warning}) {
      $warn = $self->{thresholds}->{default}->{warning};
    }
    if (exists $self->{thresholds}->{$label}->{critical}) {
      $crit = $self->{thresholds}->{$label}->{critical};
    } elsif (exists $self->{thresholds}->{default}->{critical}) {
      $crit = $self->{thresholds}->{default}->{critical};
    }
  } else {
    if ($args{warning}) {
      $warn = $args{warning};
    }
    if ($args{critical}) {
      $crit = $args{critical};
    }
  }
  if ($uom eq "%") {
    $min = 0;
    $max = 100;
  }
  if (defined $args{places}) {
    # cut off excessive decimals which may be the result of a division
    # length = places*2, no trailing zeroes
    if ($warn ne "") {
      $warn = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $warn));
    }
    if ($crit ne "") {
      $crit = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $crit));
    }
    if ($min ne "") {
      $min = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $min));
    }
    if ($max ne "") {
      $max = join("", map {
          s/\.0+$//; $_
      } map {
          s/(\.[1-9]+)0+$/$1/; $_
      } map {
          /[\+\-\d\.]+/ ? sprintf '%.'.2*$args{places}.'f', $_ : $_;
      } split(/([\+\-\d\.]+)/, $max));
    }
  }
  push @{$self->{perfdata}}, sprintf("'%s'=%s%s;%s;%s;%s;%s",
      $label, $value, $uom, $warn, $crit, $min, $max)
      if $self->selected_perfdata($label);
}

sub add_html {
  my $self = shift;
  my $line = shift;
  push @{$self->{html}}, $line;
}

sub suppress_messages {
  my $self = shift;
  $self->{suppress_messages} = 1;
}

sub clear_messages {
  my $self = shift;
  my $code = shift;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  $self->{messages}->{$code} = [];
}

sub check_messages {
  my $self = shift;
  my %args = @_;

  # Add object messages to any passed in as args
  for my $code (qw(critical warning unknown ok)) {
    my $messages = $self->{messages}->{$code} || [];
    if ($args{$code}) {
      unless (ref $args{$code} eq 'ARRAY') {
        if ($code eq 'ok') {
          $args{$code} = [ $args{$code} ];
        }
      }
      push @{$args{$code}}, @$messages;
    } else {
      $args{$code} = $messages;
    }
  }
  my %arg = %args;
  $arg{join} = ' ' unless defined $arg{join};

  # Decide $code
  my $code = OK;
  $code ||= CRITICAL  if @{$arg{critical}};
  $code ||= WARNING   if @{$arg{warning}};
  $code ||= UNKNOWN   if @{$arg{unknown}};
  return $code unless wantarray;

  # Compose message
  my $message = '';
  if ($arg{join_all}) {
      $message = join( $arg{join_all},
          map { @$_ ? join( $arg{'join'}, @$_) : () }
              $arg{critical},
              $arg{warning},
              $arg{unknown},
              $arg{ok} ? (ref $arg{ok} ? $arg{ok} : [ $arg{ok} ]) : []
      );
  }

  else {
      $message ||= join( $arg{'join'}, @{$arg{critical}} )
          if $code == CRITICAL;
      $message ||= join( $arg{'join'}, @{$arg{warning}} )
          if $code == WARNING;
      $message ||= join( $arg{'join'}, @{$arg{unknown}} )
          if $code == UNKNOWN;
      $message ||= ref $arg{ok} ? join( $arg{'join'}, @{$arg{ok}} ) : $arg{ok}
          if $arg{ok};
  }

  return ($code, $message);
}

sub status_code {
  my $self = shift;
  my $code = shift;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = uc $code;
  $code = $ERRORS{$code} if defined $code && exists $ERRORS{$code};
  $code = UNKNOWN unless defined $code && exists $STATUS_TEXT{$code};
  return "$STATUS_TEXT{$code}";
}

sub perfdata_string {
  my $self = shift;
  if (scalar (@{$self->{perfdata}})) {
    return join(" ", @{$self->{perfdata}});
  } else {
    return "";
  }
}

sub html_string {
  my $self = shift;
  if (scalar (@{$self->{html}})) {
    return join(" ", @{$self->{html}});
  } else {
    return "";
  }
}

sub nagios_exit {
  my $self = shift;
  my ($code, $message, $arg) = @_;
  $code = $ERRORS{$code} if defined $code && exists $ERRORS{$code};
  $code = UNKNOWN unless defined $code && exists $STATUS_TEXT{$code};
  $message = '' unless defined $message;
  if (ref $message && ref $message eq 'ARRAY') {
      $message = join(' ', map { chomp; $_ } @$message);
  } else {
      chomp $message;
  }
  if ($self->opts->negate) {
    my $original_code = $code;
    foreach my $from (keys %{$self->opts->negate}) {
      if ((uc $from) =~ /^(OK|WARNING|CRITICAL|UNKNOWN)$/ &&
          (uc $self->opts->negate->{$from}) =~ /^(OK|WARNING|CRITICAL|UNKNOWN)$/) {
        if ($original_code == $ERRORS{uc $from}) {
          $code = $ERRORS{uc $self->opts->negate->{$from}};
        }
      }
    }
  }
  my $output = "$STATUS_TEXT{$code}";
  $output .= " - $message" if defined $message && $message ne '';
  if (scalar (@{$self->{perfdata}})) {
    $output .= " | ".$self->perfdata_string();
  }
  $output .= "\n";
  if (! exists $self->{suppress_messages}) {
    print $output;
  }
  exit $code;
}

sub set_thresholds {
  my $self = shift;
  my %params = @_;
  if (exists $params{metric}) {
    my $metric = $params{metric};
    # erst die hartcodierten defaultschwellwerte
    $self->{thresholds}->{$metric}->{warning} = $params{warning};
    $self->{thresholds}->{$metric}->{critical} = $params{critical};
    # dann die defaultschwellwerte von der kommandozeile
    if (defined $self->opts->warning) {
      $self->{thresholds}->{$metric}->{warning} = $self->opts->warning;
    }
    if (defined $self->opts->critical) {
      $self->{thresholds}->{$metric}->{critical} = $self->opts->critical;
    }
    # dann die ganz spezifischen schwellwerte von der kommandozeile
    if ($self->opts->warningx) { # muss nicht auf defined geprueft werden, weils ein hash ist
      foreach my $key (keys %{$self->opts->warningx}) {
        next if $key ne $metric;
        $self->{thresholds}->{$metric}->{warning} = $self->opts->warningx->{$key};
      }
    }
    if ($self->opts->criticalx) {
      foreach my $key (keys %{$self->opts->criticalx}) {
        next if $key ne $metric;
        $self->{thresholds}->{$metric}->{critical} = $self->opts->criticalx->{$key};
      }
    }
  } else {
    $self->{thresholds}->{default}->{warning} =
        defined $self->opts->warning ? $self->opts->warning : defined $params{warning} ? $params{warning} : 0;
    $self->{thresholds}->{default}->{critical} =
        defined $self->opts->critical ? $self->opts->critical : defined $params{critical} ? $params{critical} : 0;
  }
}

sub force_thresholds {
  my $self = shift;
  my %params = @_;
  if (exists $params{metric}) {
    my $metric = $params{metric};
    $self->{thresholds}->{$metric}->{warning} = $params{warning} || 0;
    $self->{thresholds}->{$metric}->{critical} = $params{critical} || 0;
  } else {
    $self->{thresholds}->{default}->{warning} = $params{warning} || 0;
    $self->{thresholds}->{default}->{critical} = $params{critical} || 0;
  }
}

sub get_thresholds {
  my $self = shift;
  my @params = @_;
  if (scalar(@params) > 1) {
    my %params = @params;
    my $metric = $params{metric};
    return ($self->{thresholds}->{$metric}->{warning},
        $self->{thresholds}->{$metric}->{critical});
  } else {
    return ($self->{thresholds}->{default}->{warning},
        $self->{thresholds}->{default}->{critical});
  }
}

sub check_thresholds {
  my $self = shift;
  my @params = @_;
  my $level = $ERRORS{OK};
  my $warningrange;
  my $criticalrange;
  my $value;
  if (scalar(@params) > 1) {
    my %params = @params;
    $value = $params{value};
    my $metric = $params{metric};
    if ($metric ne 'default') {
      $warningrange = exists $self->{thresholds}->{$metric}->{warning} ?
          $self->{thresholds}->{$metric}->{warning} :
          $self->{thresholds}->{default}->{warning};
      $criticalrange = exists $self->{thresholds}->{$metric}->{critical} ?
          $self->{thresholds}->{$metric}->{critical} :
          $self->{thresholds}->{default}->{critical};
    } else {
      $warningrange = (defined $params{warning}) ?
          $params{warning} : $self->{thresholds}->{default}->{warning};
      $criticalrange = (defined $params{critical}) ?
          $params{critical} : $self->{thresholds}->{default}->{critical};
    }
  } else {
    $value = $params[0];
    $warningrange = $self->{thresholds}->{default}->{warning};
    $criticalrange = $self->{thresholds}->{default}->{critical};
  }
  if (! defined $warningrange) {
    # there was no set_thresholds for defaults, no --warning, no --warningx
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = 10, warn if > 10 or < 0
    $level = $ERRORS{WARNING}
        if ($value > $1 || $value < 0);
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+):$/) {
    # warning = 10:, warn if < 10
    $level = $ERRORS{WARNING}
        if ($value < $1);
  } elsif ($warningrange =~ /^~:([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = ~:10, warn if > 10
    $level = $ERRORS{WARNING}
        if ($value > $1);
  } elsif ($warningrange =~ /^([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = 10:20, warn if < 10 or > 20
    $level = $ERRORS{WARNING}
        if ($value < $1 || $value > $2);
  } elsif ($warningrange =~ /^@([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # warning = @10:20, warn if >= 10 and <= 20
    $level = $ERRORS{WARNING}
        if ($value >= $1 && $value <= $2);
  }
  if (! defined $criticalrange) {
    # there was no set_thresholds for defaults, no --critical, no --criticalx
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = 10, crit if > 10 or < 0
    $level = $ERRORS{CRITICAL}
        if ($value > $1 || $value < 0);
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+):$/) {
    # critical = 10:, crit if < 10
    $level = $ERRORS{CRITICAL}
        if ($value < $1);
  } elsif ($criticalrange =~ /^~:([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = ~:10, crit if > 10
    $level = $ERRORS{CRITICAL}
        if ($value > $1);
  } elsif ($criticalrange =~ /^([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = 10:20, crit if < 10 or > 20
    $level = $ERRORS{CRITICAL}
        if ($value < $1 || $value > $2);
  } elsif ($criticalrange =~ /^@([-+]?[0-9]*\.?[0-9]+):([-+]?[0-9]*\.?[0-9]+)$/) {
    # critical = @10:20, crit if >= 10 and <= 20
    $level = $ERRORS{CRITICAL}
        if ($value >= $1 && $value <= $2);
  }
  return $level;
}


package GLPlugin::Commandline::Getopt;
use strict;
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

# Standard defaults
my %DEFAULT = (
  timeout => 15,
  verbose => 0,
  license =>
"This monitoring plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
It may be used, redistributed and/or modified under the terms of the GNU
General Public Licence (see http://www.fsf.org/licensing/licenses/gpl.txt).",
);
# Standard arguments
my @ARGS = ({
    spec => 'usage|?',
    help => "-?, --usage\n   Print usage information",
  }, {
    spec => 'help|h',
    help => "-h, --help\n   Print detailed help screen",
  }, {
    spec => 'version|V',
    help => "-V, --version\n   Print version information",
  }, {
    #spec => 'extra-opts:s@',
    #help => "--extra-opts=[<section>[@<config_file>]]\n   Section and/or config_file from which to load extra options (may repeat)",
  }, {
    spec => 'timeout|t=i',
    help => sprintf("-t, --timeout=INTEGER\n   Seconds before plugin times out (default: %s)", $DEFAULT{timeout}),
    default => $DEFAULT{timeout},
  }, {
    spec => 'verbose|v+',
    help => "-v, --verbose\n   Show details for command-line debugging (can repeat up to 3 times)",
    default => $DEFAULT{verbose},
  },
);
# Standard arguments we traditionally display last in the help output
my %DEFER_ARGS = map { $_ => 1 } qw(timeout verbose);

sub _init {
  my $self = shift;
  my %params = @_;
  # Check params
  my %attr = (
    usage => 1,
    version => 0,
    url => 0,
    plugin => { default => $GLPlugin::pluginname },
    blurb => 0,
    extra => 0,
    'extra-opts' => 0,
    license => { default => $DEFAULT{license} },
    timeout => { default => $DEFAULT{timeout} },
  );

  # Add attr to private _attr hash (except timeout)
  $self->{timeout} = delete $attr{timeout};
  $self->{_attr} = { %attr };
  foreach (keys %{$self->{_attr}}) {
    if (exists $params{$_}) {
      $self->{_attr}->{$_} = $params{$_};
    } else {
      $self->{_attr}->{$_} = $self->{_attr}->{$_}->{default}
          if ref ($self->{_attr}->{$_}) eq 'HASH' &&
              exists $self->{_attr}->{$_}->{default};
    }
  }
  # Chomp _attr values
  chomp foreach values %{$self->{_attr}};

  # Setup initial args list
  $self->{_args} = [ grep { exists $_->{spec} } @ARGS ];

  $self
}

sub new {
  my $class = shift;
  my $self = bless {}, $class;
  $self->_init(@_);
}

sub add_arg {
  my $self = shift;
  my %arg = @_;
  push (@{$self->{_args}}, \%arg);
}

sub getopts {
  my $self = shift;
  my %commandline = ();
  my @params = map { $_->{spec} } @{$self->{_args}};
  if (! GetOptions(\%commandline, @params)) {
    $self->print_help();
    exit 0;
  } else {
    no strict 'refs';
    no warnings 'redefine';
    do { $self->print_help(); exit 0; } if $commandline{help};
    do { $self->print_version(); exit 0 } if $commandline{version};
    do { $self->print_usage(); exit 3 } if $commandline{usage};
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; } @{$self->{_args}}) {
      my $field = $_;
      *{"$field"} = sub {
        return $self->{opts}->{$field};
      };
    }
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; }
        grep { exists $_->{required} && $_->{required} } @{$self->{_args}}) {
      do { $self->print_usage(); exit 0 } if ! exists $commandline{$_};
    }
    foreach (grep { exists $_->{default} } @{$self->{_args}}) {
      $_->{spec} =~ /^([\w\-]+)/;
      my $spec = $1;
      $self->{opts}->{$spec} = $_->{default};
    }
    foreach (keys %commandline) {
      $self->{opts}->{$_} = $commandline{$_};
    }
    foreach (grep { exists $_->{env} } @{$self->{_args}}) {
      $_->{spec} =~ /^([\w\-]+)/;
      my $spec = $1;
      if (exists $ENV{'NAGIOS__HOST'.$_->{env}}) {
        $self->{opts}->{$spec} = $ENV{'NAGIOS__HOST'.$_->{env}};
      }
      if (exists $ENV{'NAGIOS__SERVICE'.$_->{env}}) {
        $self->{opts}->{$spec} = $ENV{'NAGIOS__SERVICE'.$_->{env}};
      }
    }
    foreach (grep { exists $_->{aliasfor} } @{$self->{_args}}) {
      my $field = $_->{aliasfor};
      $_->{spec} =~ /^([\w\-]+)/;
      my $aliasfield = $1;
      next if $self->{opts}->{$field};
      *{"$field"} = sub {
        return $self->{opts}->{$aliasfield};
      };
    }
  }
}

sub create_opt {
  my $self = shift;
  my $key = shift;
  no strict 'refs';
  *{"$key"} = sub {
      return $self->{opts}->{$key};
  };
}

sub override_opt {
  my $self = shift;
  my $key = shift;
  my $value = shift;
  $self->{opts}->{$key} = $value;
}

sub get {
  my $self = shift;
  my $opt = shift;
  return $self->{opts}->{$opt};
}

sub print_help {
  my $self = shift;
  $self->print_version();
  printf "\n%s\n", $self->{_attr}->{license};
  printf "\n%s\n\n", $self->{_attr}->{blurb};
  $self->print_usage();
  foreach (@{$self->{_args}}) {
    printf " %s\n", $_->{help};
  }
  exit 0;
}

sub print_usage {
  my $self = shift;
  printf $self->{_attr}->{usage}, $self->{_attr}->{plugin};
  print "\n";
}

sub print_version {
  my $self = shift;
  printf "%s %s", $self->{_attr}->{plugin}, $self->{_attr}->{version};
  printf " [%s]", $self->{_attr}->{url} if $self->{_attr}->{url};
  print "\n";
}

sub print_license {
  my $self = shift;
  printf "%s\n", $self->{_attr}->{license};
  print "\n";
}


package GLPlugin::Item;
our @ISA = qw(GLPlugin);

use strict;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub check {
  my $self = shift;
  my $lists = shift;
  my @lists = $lists ? @{$lists} : grep { ref($self->{$_}) eq "ARRAY" } keys %{$self};
  foreach my $list (@lists) {
    $self->add_info('checking '.$list);
    foreach my $element (@{$self->{$list}}) {
      $element->blacklist() if $self->is_blacklisted();
      $element->check();
    }
  }
}


package GLPlugin::TableItem;
our @ISA = qw(GLPlugin::Item);

use strict;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {};
  bless $self, $class;
  foreach (keys %params) {
    $self->{$_} = $params{$_};
  }
  if ($self->can("finish")) {
    $self->finish(%params);
  }
  return $self;
}

sub check {
  my $self = shift;
  # some tableitems are not checkable, they are only used to enhance other
  # items (e.g. sensorthresholds enhance sensors)
  # normal tableitems should have their own check-method
}


package Classes::Device;
our @ISA = qw(GLPlugin);
use strict;


sub classify {
  my $self = shift;
  #if (! (($self->opts->ashost || $self->opts->mshost) && $self->opts->username && $self->opts->password)) {
  if (! ($self->opts->ashost || $self->opts->mshost)) {
    $self->add_unknown('specify at least hostname, username and password');
  } else {
    bless $self, 'Classes::SAP';
    $self->debug('using Classes::SAP');
    $self->check_rfc_and_model();
  }
  if ($self->opts->mode =~ /^my-/) {
    $self->load_my_extension();
  }
}

package Classes::SAP;
our @ISA = qw(Classes::Device);

use strict;
use File::Basename;
use Time::HiRes;
use Digest::MD5 qw(md5_hex);
use Data::Dumper;
use AutoLoader;
our $AUTOLOAD;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $blacklist = undef;
  our $session = undef;
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $oidtrace = [];
  our $uptime = 0;
}

sub check_rfc_and_model {
  my $self = shift;
  chdir("/tmp");
  if (eval "require sapnwrfc") {
    my %params = (
      'LCHECK' => '1',
    );
    if ($self->opts->ashost) {
      $params{ASHOST} = $self->opts->ashost;
    }
    if ($self->opts->sysnr) {
      $params{SYSNR} = $self->opts->sysnr;
    }
    if ($self->opts->mshost) {
      $params{MSHOST} = $self->opts->mshost;
    }
    if ($self->opts->msserv) {
      $params{MSSERV} = $self->opts->msserv;
    }
    if ($self->opts->r3name) {
      $params{R3NAME} = $self->opts->r3name;
    }
    if ($self->opts->group) {
      $params{GROUP} = $self->opts->group;
    }
    if ($self->opts->gwhost) {
      $params{GWHOST} = $self->opts->gwhost;
    }
    if ($self->opts->gwserv) {
      $params{GWSERV} = $self->opts->gwserv;
    }
    if ($self->opts->client) {
      $params{CLIENT} = $self->opts->client;
    }
    if ($self->opts->lang) {
      $params{LANG} = $self->opts->lang;
    }
    if ($self->opts->username) {
      $params{USER} = $self->opts->username;
    }
    if ($self->opts->password) {
      $params{PASSWD} = $self->decode_password($self->opts->password);
    }
    if ($self->opts->verbose) {
      $params{DEBUG} = '1';
      $params{TRACE} = '1';
    }
    if ($self->opts->mode =~ /sapinfo/) {
      $params{LCHECK} = '0';
      $params{USER} = "";
      $params{PASSWD} = "";
      $params{ABAP_DEBUG} = 0;
      $params{SAPGUI} = 0;
    }
    $self->{tic} = Time::HiRes::time();
    my $session = undef;
    eval {
      $session = SAPNW::Rfc->rfc_connect(%params);
    };
    if ($@) {
      $self->add_message(CRITICAL,
          sprintf 'cannot create rfc connection: %s', $@);
      $self->debug(Data::Dumper::Dumper(\%params));
    } elsif (! defined $session) {
      $self->add_message(CRITICAL,
          sprintf 'cannot create rfc connection');
      $self->debug(Data::Dumper::Dumper(\%params));
    } else {
      $Classes::SAP::session = $session;
    }
    $self->{tac} = Time::HiRes::time();
  } else {
    $self->add_message(CRITICAL,
        'could not load perl module SAPNW');
  }
}

sub session {
  my $self = shift;
  return $Classes::SAP::session;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /^server::connectiontime/) {
    my $fc = undef;
    if ($self->mode =~ /^server::connectiontime::sapinfo/) {
      eval {
        my $fl = $self->session->function_lookup("RFC_SYSTEM_INFO");
        $fc = $fl->create_function_call;
        $fc->invoke();
        printf "rrc %s\n", Data::Dumper::Dumper($fc->RFCSI_EXPORT);
      };
      if ($@) {
        printf "crash %s\n", $@;
      }
      $self->{tac} = Time::HiRes::time();
    }
    $self->{connection_time} = $self->{tac} - $self->{tic};
    $self->set_thresholds(warning => 1, critical => 5);
    $self->add_message($self->check_thresholds($self->{connection_time}),
         sprintf "%.2f seconds to connect as %s@%s",
              $self->{connection_time}, $self->opts->username,
              $self->session->connection_attributes->{sysId});
    $self->add_perfdata(
        label => 'connection_time',
        value => $self->{connection_time},
    );
    if ($self->mode =~ /^server::connectiontime::sapinfo/) {
      # extraoutput
      # $fc
    }
  } elsif ($self->mode =~ /^server::ccms::/) {
    $self->analyze_and_check_ccms_subsystem("Classes::SAP::Component::CCMS");
  } elsif ($self->mode =~ /^server::snap::/) {
    $self->analyze_and_check_snap_subsystem("Classes::SAP::Component::SNAP");
  } elsif ($self->mode =~ /^server::updates::/) {
    $self->analyze_and_check_snap_subsystem("Classes::SAP::Component::UpdateSubsystem");
  } elsif ($self->mode =~ /^server::backgroundjobs::/) {
    $self->analyze_and_check_snap_subsystem("Classes::SAP::Component::BackgroundjobSubsystem");
  }
}

sub validate_args {
  my $self = shift;
  $self->SUPER::validate_args();
  $MTE::separator = $self->opts->separator if $self->opts->separator;
  if ($self->opts->get("with-my-modules-dyn-dir")) {
  }
}

sub create_statefile {
  my $self = shift;
  my %params = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s_%s_%s%s", $self->statefilesdir(),
      $self->opts->ashost, $self->opts->sysnr, $self->opts->mode, lc $extension;
}

sub epoch_to_abap_date {
  my $self = shift;
  my $timestamp = shift || time;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
      localtime($timestamp);
  return sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
}

sub epoch_to_abap_time {
  my $self = shift;
  my $timestamp = shift || time;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
      localtime($timestamp);
  return sprintf "%02d%02d%02d", $hour, $min, $sec;
}

sub epoch_to_abap_date_and_time {
  my $self = shift;
  my $timestamp = shift || time;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
      localtime($timestamp);
  my $date = sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
  my $time = sprintf "%02d%02d%02d", $hour, $min, $sec;
  return ($date, $time);
}

sub DESTROY {
  my $self = shift;
  my $plugin_exit = $?;
  if ($Classes::SAP::session) {
    $Classes::SAP::session->disconnect();
  }
  #$self->debug("disconnected");
  my $now = time;
  eval {
    my $ramschdir = $ENV{RFC_TRACE_DIR} ? $ENV{RFC_TRACE_DIR} : "/tmp";
    unlink $ramschdir."/dev_rfc.trc" if -f $ramschdir."/dev_rfc.trc";
    no warnings "all";
    foreach (glob $ramschdir."/rfc*.trc") {
      eval {
        if (($now - (stat $_)[9]) > 300) {
          unlink $_;
        }
      };
    }
  };
  $? = $plugin_exit;
}

package Classes::SAP::Component::CCMS;
our @ISA = qw(GLPlugin::Item);
use strict;


sub session {
  my $self = shift;
  return $Classes::SAP::session;
}

sub init {
  my $self = shift;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
      localtime(time);
  {
    no strict 'refs';
    *{'Classes::SAP::Component::CCMS::create_statefile'} = \&{'Classes::SAP::create_statefile'};
  }
  my $bapi_tic = Time::HiRes::time();
  if ($self->mode =~ /server::ccms::/) {
    eval {
      my $rcb = $self->session->function_lookup("SXMI_VERSIONS_GET");
      my $tsl = $rcb->create_function_call;
      #$tsl->INTERFACE("XMB"); # weglassen fuer alle interfaces
      $tsl->invoke;
      my $xmbversion = "0.1";
      my $xalversion = "0.1";
      foreach my $row (@{$tsl->VERSIONS}) {
        $xmbversion = $row->{'VERSION'} if $row->{'INTERFACE'} eq "XMB";
        $xalversion = $row->{'VERSION'} if $row->{'INTERFACE'} eq "XAL";
      }
      my $fl = $self->session->function_lookup("BAPI_XMI_LOGON");
      my $fc = $fl->create_function_call;
      $fc->EXTCOMPANY('LAUSSER');
      $fc->EXTPRODUCT('CHECK_SAP_HEALTH');
      $fc->INTERFACE('XAL');
      $fc->parameter('VERSION')->value($xalversion);
      $fc->invoke;
      if ($fc->RETURN->{TYPE} !~ /^E/) {
        if ($self->mode =~ /server::ccms::moniset::list/) {
          $fl = $self->session->function_lookup("BAPI_SYSTEM_MS_GETLIST");
          $fc = $fl->create_function_call;
          $fc->EXTERNAL_USER_NAME("Agent");
          $fc->invoke;
          my @sets = @{$fc->MONITOR_SETS};
          foreach (@sets) {
            printf "%s\n", $_->{NAME};
          }
          $self->add_ok("have fun");

        } elsif ($self->mode =~ /server::ccms::monitor::list/) {
          $fl = $self->session->function_lookup("BAPI_SYSTEM_MON_GETLIST");
          # details with BAPI_SYSTEM_MS_GETDETAILS
          $fc = $fl->create_function_call;
          $fc->EXTERNAL_USER_NAME("Agent");
          if ($self->opts->name) {
            $fc->MONI_SET_NAME({
                NAME => $self->opts->name,
            });
          }
          $fc->invoke;
          my @names = @{$fc->MONITOR_NAMES};
          foreach my $ms (sort keys %{{ map {$_ => 1} map { $_->{MS_NAME} } @names }}) {
            printf "%s\n", $ms;
            foreach my $moni (sort keys %{{ map {$_ => 1} map { $_->{MONI_NAME} }
                grep { $_->{MS_NAME} eq $ms } @names }}) {
              printf " %s\n", $moni;
            }
          }
          $self->add_ok("have fun");
        } elsif ($self->mode =~ /server::ccms::mte::/) {
          if (! $self->opts->name || ! $self->opts->name2) {
            die "__no_internals__you need to specify --name moniset --name2 monitor";
          }
          if ($self->mode =~ /server::ccms::mte::list/) {
            $self->update_tree_cache(1);
          }
          my @tree_nodes = $self->update_tree_cache(0);
          my %seen;
          my @mtes = sort {
              $a->{MTNAMELONG} cmp $b->{MTNAMELONG}
          } grep {
            $self->filter_name3($_->{MTNAMELONG})
          } grep {
            ! $seen{$_->tid_flat()}++;
          } map { 
              MTE->new(%{$_});
          } @tree_nodes;
          if ($self->mode =~ /server::ccms::mte::list/) {
            foreach my $mte (@mtes) {
              printf "%s %d\n", $mte->{MTNAMELONG}, $mte->{MTCLASS};
            }
          } elsif ($self->mode =~ /server::ccms::mte::check/) {
            $self->set_thresholds();
            foreach my $mte (@mtes) {
              next if grep { $mte->{MTCLASS} == $_ } (50, 70, 199);
              $self->debug(sprintf "collect_details for %s", $mte->{MTNAMELONG});
              $mte->collect_details($self->session);
              $mte->check();
            }
            if (! @mtes) {
              $self->add_unknown("no mtes");
            }
          }
        }
        $self->debug("logoff");
        $fl = $self->session->function_lookup("BAPI_XMI_LOGOFF");
        $fc = $fl->create_function_call;
        $fc->INTERFACE('XAL');
        $fc->invoke;
      } else {
        $self->add_critical($fc->RETURN->{MESSAGE});
      }
    };
    if ($@) {
      my $message = $@;
      $message =~ s/[^[:ascii:]]//g;
      $message =~ s/\s+$//g;
      chomp($message);
      if ($message =~ /__no_internals__/) {
        $message =~ s/at $GLPlugin::pluginname line.*//g;
        $message =~ s/__no_internals__//g;
      }
      $self->add_unknown($message);
    }
  }
  my $bapi_tac = Time::HiRes::time();
  $self->set_thresholds(warning => 5, critical => 10);
  #$self->add_message($self->check_thresholds($bapi_tac - $bapi_tic),
  #     sprintf "runtime was %.2fs", $bapi_tac - $bapi_tic);
  #$self->add_perfdata(
  #    label => 'runtime',
  #    value => $bapi_tac - $bapi_tic,
  #    warning => $self->{warning},
  #    critical => $self->{critical},
  #);
}

sub update_tree_cache {
  my $self = shift;
  my $force = shift;
  my @tree_nodes = ();
  my $statefile = $self->create_statefile(name => 'tree_'.$self->opts->name.'_'.$self->opts->name2);
  my $update = time - 24 * 3600;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug(sprintf "updating the tree cache for %s %s",
        $self->opts->name, $self->opts->name2);
    my $fl = $self->session->function_lookup("BAPI_SYSTEM_MON_GETTREE");
    my  $fc = $fl->create_function_call;
    $fc->EXTERNAL_USER_NAME("Agent");
    $fc->MONITOR_NAME({
      MS_NAME => $self->opts->name,
      MONI_NAME => $self->opts->name2,
    });
    $fc->invoke;
    # TREE_NODES
    if ($fc->RETURN->{TYPE} =~ /^E/) {
      $self->add_critical($fc->RETURN->{MESSAGE});
    } else {
      map { push(@tree_nodes, $_) } @{$fc->TREE_NODES};
    }
    $self->debug(sprintf "updated the tree cache for %s %s",
        $self->opts->name, $self->opts->name2);
    $self->save_state(name => 'tree_'.$self->opts->name.'_'.$self->opts->name2, save => \@tree_nodes);
  }
  my $content = do { local (@ARGV, $/) = $statefile; my $x = <>; close ARGV; $x };
  my $VAR1;
  $VAR1 = eval "$content";
  my $cache = $VAR1;;
  @tree_nodes = @{$cache};
  $self->debug(sprintf "return cached tree nodes for %s %s",
      $self->opts->name, $self->opts->name2);
  return @tree_nodes;
}

sub map_alvalue {
  my $self = shift;
  my $value = shift;
  if ($value && 1 <= $value && $value <= 3) {
    return {
      1 => 0,
      2 => 1,
      3 => 2,
    }->{$value};
  } else {
    return 3;
  }
}



package MTE;
our @ISA = qw(GLPlugin::TableItem);
use strict;

#our @ISA = qw(SAP::CCMS);
# can't inherit, because this undefines the session handle. hurnmatz, greisliche

use constant OK         => 0;
use constant WARNING    => 1;
use constant CRITICAL   => 2;
use constant UNKNOWN    => 3;

use constant { GREEN => 1, YELLOW => 2, RED => 3, GRAY => 4 };

# http://www.benx.de/en/sap/program/RSALBAPI---code.htm
use constant MT_CLASS_NO_CLASS    => 0;
use constant MT_CLASS_SUMMARY     => 50;
use constant MT_CLASS_MONIOBJECT  => 70;
use constant MT_CLASS_FIRST_MA    => 99;
use constant MT_CLASS_PERFORMANCE => 100;
use constant MT_CLASS_MSG_CONT    => 101;
use constant MT_CLASS_SINGLE_MSG  => 102;
use constant MT_CLASS_HEARTBEAT   => 103;
use constant MT_CLASS_LONGTEXT    => 110;
use constant MT_CLASS_SHORTTEXT   => 111;
use constant MT_CLASS_VIRTUAL     => 199;
# skip 50, 70, 199

use constant AL_VAL_INAKTIV => 0;
use constant AL_VAL_GREEN => 1;
use constant AL_VAL_YELLOW => 2;
use constant AL_VAL_RED => 3;

# Attribute Type
#  Description
#  
# This graphic is explained in the accompanying text Performance Attribute
#  Collects reported performance values and calculates the average
#  
# This graphic is explained in the accompanying text Status Attribute
#  Reports error message texts and alert status
#  
# This graphic is explained in the accompanying text Heartbeat Attribute
#  Checks whether components of the SAP system are active; if no values are reported for a monitoring attribute for a long time, it triggers an alert
#  
# This graphic is explained in the accompanying text Log Attribute
#  Checks log and trace files (these attributes can use an existing log mechanism, such as the SAP system log, or they can be used by an application for the implementation of a separate log)
#  
# This graphic is explained in the accompanying text Text Attribute
#  Allows a data supplier to report information that is not evaluated for alerts; the text can be updated as required
#  


our $separator = "\\";

{
  sub sap2nagios {
    my $sap = shift;
    my $nagios = 0;
    if ($sap == 1) {
      return OK;
    } elsif ($sap == 2) {
      return WARNING;
    } elsif ($sap == 3) {
      return CRITICAL;
    } elsif ($sap == 4) {
      return UNKNOWN;
    } else {
      return UNKNOWN;
    }
  }
}


sub new {
  my $class = shift;
  my %params = @_;
  my $self = {};
  bless $self, $class;
  foreach (qw(MTSYSID MTCLASS MTMCNAME MTNUMRANGE MTUID MTINDEX EXTINDEX
      OBJECTNAME MTNAMESHRT PRNTMTNAMESHRT)) {
    $self->{$_} = $self->rstrip($params{$_}) if defined $params{$_};
  }
  foreach (qw(ALTREENUM ALIDXINTRE ALLEVINTRE ALPARINTRE VALINDEX)) {
    $self->{$_} = $self->rstrip($params{$_}) if defined $params{$_};
  }
  # CUSGRPNAME = Eigenschaften: ..der MTE-Klasse
  $self->{MTNAMELONG} = $self->mkMTNAMELONG;
  $self->{TID} = $self->tid();
  if ($self->{MTCLASS} == MT_CLASS_PERFORMANCE) {
    bless $self, "MTE::Performance";
  } elsif ($self->{MTCLASS} == MT_CLASS_MSG_CONT) {
    bless $self, "MTE::ML";
  } elsif ($self->{MTCLASS} == MT_CLASS_SINGLE_MSG) {
    bless $self, "MTE::SM";
  } elsif ($self->{MTCLASS} == MT_CLASS_SHORTTEXT) {
    bless $self, "MTE::ST";
  } else {
  }
  return $self;
                my $bapi = {
                    MT_CLASS_PERFORMANCE() => "BAPI_SYSTEM_MTE_GETPERFCURVAL",
                    MT_CLASS_SINGLE_MSG() => "BAPI_SYSTEM_MTE_GETSMVALUE",
                    #MT_CLASS_MSGCONT() => "BAPI_SYSTEM_MTE_?",
                    MT_CLASS_LONGTEXT() => "BAPI_SYSTEM_MTE_GETMLCURVAL",
                    MT_CLASS_SHORTTEXT() => "BAPI_SYSTEM_MTE_GETTXTPROP",
                }->{$self->{MTCLASS}};

}

sub mkMTNAMELONG {
  my $self = shift;
  my $myname = "";
  if ($self->{MTSYSID}) {
    $myname = $myname.$self->{MTSYSID}.$MTE::separator;
  } else {
    #return undef;
  }
  $myname = $myname.$self->{MTMCNAME}.$MTE::separator;
  if ($self->{PRNTMTNAMESHRT} && $self->{PRNTMTNAMESHRT} ne $self->{MTSYSID}.$MTE::separator.$self->{MTMCNAME}) {
    $myname = $myname.$self->{PRNTMTNAMESHRT}.$MTE::separator;
  }
  if ($self->{OBJECTNAME}) {
    $myname = $myname.$self->{OBJECTNAME}.$MTE::separator;
  } else {
    #return undef;
  }
  if ($self->{OBJECTNAME} ne $self->{MTNAMESHRT}) {
    $myname = $myname.$self->{MTNAMESHRT};
  }
  return $myname;
}

sub collect_details {
  my $self = shift;
  my $session = shift;
  my $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETGENPROP");
  my $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  #next if $fc->ACTUAL_ALERT_DATA->{VALUE} == 0;
  $self->{ACTUAL_ALERT_DATA_VALUE} = $fc->ACTUAL_ALERT_DATA->{VALUE};
  $self->{ACTUAL_ALERT_DATA_LEVEL} = $fc->ACTUAL_ALERT_DATA->{LEVEL};
}

sub check {
  my $self = shift;
  $self->debug(sprintf "mte %s has alert %s",
      $self->mkMTNAMELONG(), MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
  $self->add_info("");
  $self->add_message(MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
}

sub tid {
  my $self = shift;
  if (! exists $self->{tid}) {
    $self->{tid} = {
      MTSYSID => $self->{MTSYSID},
      MTMCNAME => $self->{MTMCNAME},
      MTNUMRANGE => $self->{MTNUMRANGE},
      MTUID => $self->{MTUID},
      MTCLASS => $self->{MTCLASS},
      MTINDEX => $self->{MTINDEX},
      EXTINDEX => $self->{EXTINDEX},
    };
  }
  return $self->{tid};
}

sub tid_flat {
  my $self = shift;
  return sprintf "%s_%s_%s_%s_%s_%s_%s_",
      $_->{MTSYSID},
      $_->{MTMCNAME},
      $_->{MTNUMRANGE},
      $_->{MTUID},
      $_->{MTCLASS},
      $_->{MTINDEX},
      $_->{EXTINDEX};
}

sub extra_props {
  my $self = shift;
  my %params = @_;
}

sub rstrip {
  my $self = shift;
  my $message = shift;
  $message =~ s/\s+$//g;
  chomp $message;
  return $message;
}

sub strip {
  my $self = shift;
  my $message = shift;
  if (ref($message) eq "HASH") {
    foreach (keys %{$message}) {
      $self->strip($message->{$_});
    }
  } else {
    $message =~ s/^\s+//g;
    $message = $self->rstrip($message);
  }
  return $message;
}


package MTE::Performance;
use strict;
our @ISA = qw(MTE);
use constant { GREEN => 1, YELLOW => 2, RED => 3, GRAY => 4 };

sub collect_details {
  my $self = shift;
  my $session = shift;
  $self->SUPER::collect_details($session);
  my $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETPERFCURVAL");
  my $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  foreach (qw(ALRELEVVAL AVG15PVAL ALRELVALTI AVG05PVAL MAXPFDATE ALRELVALDT MINPFDATE
      LASTPERVAL MAXPFTIME AVG15SVAL AVG15CVAL MAXPFVALUE AVG01PVAL AVG01SVAL MINPFVALUE
      LASTALSTAT AVG01CVAL AVG05CVAL MINPFTIME AVG05SVAL)) {
    $self->{$_} = $self->strip($fc->CURRENT_VALUE->{$_});
  }
  $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETPERFPROP");
  $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  foreach (qw(DECIMALS MSGID RELVALTYPE VALUNIT ATTRGROUP
      TRESHR2Y THRESHDIR TRESHG2Y TRESHY2G THRESHSTAT MSGCLASS TRESHY2R)) {
    $self->{$_} = $self->strip($fc->PROPERTIES->{$_});
  }
  if ($self->{DECIMALS} != 0) {
    # aus SAP_BASIS Modul BC-CCM-MON-OS
    my $exp = 10 ** $self->{DECIMALS};
    $self->{ALRELEVVAL} = sprintf("%.*f", $self->{DECIMALS}, $self->{ALRELEVVAL} / $exp);
    foreach (qw(TRESHR2Y TRESHG2Y TRESHY2G TRESHY2R)) {
      $self->{$_} = sprintf("%.*f", $self->{DECIMALS}, $self->{$_} / $exp) if $self->{$_};
    }
  }
}

sub check {
  my $self = shift;
  my $perfdata = {
    label => $self->{OBJECTNAME}."_".$self->{MTNAMESHRT},
    value => $self->{ALRELEVVAL},
  };
  if ($self->{VALUNIT}) {
    my $unit = lc $self->{VALUNIT};
    $unit = "ms" if $unit eq "msec";
    if ($unit =~ /^([u,m]{0,1}s|%|[kmgt]{0,1}b)$/) {
      $perfdata->{uom} = $unit;
    }
  }
  if ($self->{THRESHDIR} == 1 || $self->{THRESHDIR} == 2) {
    if ($self->{THRESHDIR} == 1) {
      $perfdata->{warning} = $self->{TRESHG2Y};
      $perfdata->{critical} = $self->{TRESHY2R};
    } else {
      $perfdata->{warning} = $self->{TRESHG2Y}.":";
      $perfdata->{critical} = $self->{TRESHY2R}.":";
    }
  }
  $self->set_thresholds(warning => $perfdata->{warning}, critical => $perfdata->{critical}, metric => $perfdata->{label});
  delete $perfdata->{warning};
  delete $perfdata->{critical};
  $self->add_perfdata(%{$perfdata});
  $self->add_message(
      $self->check_thresholds(
          value => $self->{ALRELEVVAL}, metric => $self->{OBJECTNAME}."_".$self->{MTNAMESHRT}),
      sprintf "%s %s = %s%s", $self->{OBJECTNAME}, $self->{MTNAMESHRT}, $self->{ALRELEVVAL}, $self->{VALUNIT}
  );
}

sub nagios_level { #deprecated
  my $self = shift;
  if ($self->{ACTUAL_ALERT_DATA_VALUE} == 0) {
    if ($self->{THRESHDIR} == 1 || $self->{THRESHDIR} == 2) {
      # this mte is threshold driven
      if ($self->{THRESHDIR} == 1) {
        if ($self->{ALRELEVVAL} > $self->{TRESHY2R}) {
          $self->{ACTUAL_ALERT_DATA_VALUE} = RED;
        } elsif ($self->{ALRELEVVAL} > $self->{TRESHG2Y}) {
          $self->{ACTUAL_ALERT_DATA_VALUE} = YELLOW;
        } else {
          $self->{ACTUAL_ALERT_DATA_VALUE} = GREEN;
        }
      } else {
        if ($self->{ALRELEVVAL} < $self->{TRESHY2R}) {
          $self->{ACTUAL_ALERT_DATA_VALUE} = RED;
        } elsif ($self->{ALRELEVVAL} < $self->{TRESHG2Y}) {
          $self->{ACTUAL_ALERT_DATA_VALUE} = YELLOW;
        } else {
          $self->{ACTUAL_ALERT_DATA_VALUE} = GREEN;
        }
      }
    }
  }
  return MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE});
}



package MTE::ML;
our @ISA = qw(MTE);
use strict;

sub collect_details {
  my $self = shift;
  my $session = shift;
  $self->SUPER::collect_details($session);
  my $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETMLCURVAL");
  my $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  foreach (qw(MSG)) {
    $self->{$_} = $self->strip($fc->XMI_MSG_EXT->{$_});
  }
}

sub check {
  my $self = shift;
  $self->debug(sprintf "mte %s has alert %s",
      $self->mkMTNAMELONG(), MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
  $self->add_info($self->{MTNAMESHRT}." = ".$self->{MSG});
  $self->add_message(MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
}


package MTE::SM;
our @ISA = qw(MTE);
use strict;

sub collect_details {
  my $self = shift;
  my $session = shift;
  $self->SUPER::collect_details($session);
  my $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETSMVALUE");
  my $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  foreach (qw(MSG SMSGDATE SMSGDATE SMSGVALUE)) {
    $self->{$_} = $self->strip($fc->VALUE->{$_});
  }
}

sub check {
  my $self = shift;
  $self->debug(sprintf "mte %s has alert %s",
      $self->mkMTNAMELONG(), MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
  $self->{MSG} ||= "<empty>";
  $self->add_info($self->{MTNAMESHRT}." = ".$self->{MSG});
  $self->add_message(MTE::sap2nagios($self->{ACTUAL_ALERT_DATA_VALUE}));
}


package MTE::ST;
our @ISA = qw(MTE);
use strict;

sub collect_details {
  my $self = shift;
  my $session = shift;
  $self->SUPER::collect_details($session);
  my $fl = $session->function_lookup("BAPI_SYSTEM_MTE_GETTXTPROP");
  my $fc = $fl->create_function_call;
  $fc->TID($self->tid);
  $fc->EXTERNAL_USER_NAME("CHECK_SAP_HEALTH");
  $fc->invoke;
  foreach (qw(TEXT)) {
    $self->{$_} = $self->strip($fc->PROPERTIES->{$_});
  }
}

sub check {
  my $self = shift;
  $self->debug(sprintf "mte %s has alert 0",
      $self->mkMTNAMELONG());
  $self->{TEXT} ||= "<empty>";
  $self->add_info($self->{MTNAMESHRT}." = ".$self->{TEXT});
  $self->add_ok();
  if ($self->{TEXT} =~ /([\d\.]+)\s*(s|%|[kmgt]{0,1}b|ms|msec)/) {
    my $value = $1;
    my $unit = $2;
    $self->add_perfdata(
        label => $self->{OBJECTNAME}."_".$self->{MTNAMESHRT},
        value => $value,
        uom => $unit eq "msec" ? "ms" : $unit,
    );
  }
}

package Classes::SAP::Component::SNAP;
our @ISA = qw(GLPlugin::Item);
use strict;

sub session {
  my $self = shift;
  return $Classes::SAP::session;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /server::snap::shortdumps/) {
    eval {
      my $now = time - 1;
      my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
          localtime($now);
      my $todate = sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
      my $totime = sprintf "%02d%02d%02d", $hour, $min, $sec;
      my $from = $self->opts->lookback ? $now - $self->opts->lookback :
          $self->load_state( name => "to" ) ? $self->load_state( name => "to" )->{to} :
          $now - 3600;
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
          localtime($from + 1);
      my $fromdate = sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
      my $fromtime = sprintf "%02d%02d%02d", $hour, $min, $sec;
      my $fl = $self->session->function_lookup("RFC_READ_TABLE");
      my $fc = $fl->create_function_call;
      $fc->QUERY_TABLE("SNAP");
      $fc->DELIMITER(";");
      my $condition = sprintf "SEQNO = '000' AND (DATUM > '%s' OR (DATUM = '%s' AND UZEIT > '%s')) AND (DATUM < '%s' OR (DATUM = '%s' AND UZEIT <= '%s'))",
          $fromdate, $fromdate, $fromtime, $todate, $todate, $totime;
      my @options = ();
      while ($condition ne "") {
        $condition =~ /(.{1,70}(\s|$))/ms;
        push(@options, {'TEXT' => $1});
        $condition = $';
      }
      $fc->OPTIONS(\@options);
      $fc->FIELDS([
          { 'FIELDNAME' => 'DATUM' },
          { 'FIELDNAME' => 'UZEIT' },
          { 'FIELDNAME' => 'AHOST' },
          { 'FIELDNAME' => 'UNAME' },
          { 'FIELDNAME' => 'MANDT' },
          { 'FIELDNAME' => 'FLIST' }
      ]);
      $fc->invoke;
      #printf "%s\n", Data::Dumper::Dumper($fc);
      my @rows = @{$fc->DATA};
      my @shortdumps = ();
      foreach (@rows) {
        my $shortdump = {};
        (my $dump = $_->{WA}) =~ s/\s+$//;
        ($shortdump->{datum}, $shortdump->{uzeit},
            $shortdump->{ahost}, $shortdump->{uname},
            $shortdump->{mandt}, $shortdump->{flist}) = 
            map { s/^\s+//; s/\s+$//; $_ } split(";", $dump);
        $shortdump->{error} = substr($shortdump->{flist}, 5,
            (index($shortdump->{flist}, 'AP0') - 5));
        $shortdump->{program} = substr($shortdump->{flist},
            (index($shortdump->{flist}, 'AP0') + 5),
            (index($shortdump->{flist}, 'AI0') -
            (index($shortdump->{flist}, 'AP0') + 5)));
        $shortdump->{bgcolor} = "#f83838";
        next if ! $self->filter_name($shortdump->{uname});
        next if ! $self->filter_name2($shortdump->{program});
        push(@shortdumps, $shortdump);
      }
      if (scalar(@shortdumps) == 0) {
        $self->add_ok(sprintf "no new shortdumps between %s %s and %s %s",
            $fromdate, $fromtime, $todate, $totime);
      } else {
        if ($self->mode =~ /server::snap::shortdumps::list/) {
          foreach my $row (@rows) {
            (my $dump = $row->{WA}) =~ s/\s+$//;
            $dump = join(";", map { s/^\s+//; s/\s+$//; $_ } split(";", $dump));
            printf "%s\n", $dump;
          }
        } elsif ($self->mode =~ /server::snap::shortdumps::/) {
          my $num_shortdumps = scalar(@shortdumps);
          $self->add_info(sprintf "%d new shortdumps appeared between %s %s and %s %s",
              $num_shortdumps, $fromdate, $fromtime, $todate, $totime);
          $self->set_thresholds(warning => 50, critical => 100, metric => 'shortdumps');
          $self->add_message($self->check_thresholds(value => $num_shortdumps, metric => 'shortdumps'));
          $self->add_perfdata(
              label => 'shortdumps',
              value => $num_shortdumps
          );
          my $table = [];
          my @titles = ();
          my $unique_dumps = {};
          if ($self->mode =~ /server::snap::shortdumps::recurrence/) {
            my $max_unique_shortdumps = 0;
            my $max_unique_overflows = 0;
            foreach my $shortdump (@shortdumps) {
              my $signature = join("_", map { $shortdump->{$_} } qw(ahost uname mandt error program));
              if (! exists $unique_dumps->{$signature}) {
                $unique_dumps->{$signature} = {
                  count => 1,
                  dump => $shortdump,
                };
              } else {
                $unique_dumps->{$signature}->{count}++;
              }
            }
            $self->set_thresholds(warning => 50, critical => 100, metric => 'max_unique_shortdumps');
            foreach my $unique_dump (map { $unique_dumps->{$_} } keys %{$unique_dumps}) {
              $max_unique_shortdumps = $unique_dump->{count} if ($unique_dump->{count} > $max_unique_shortdumps);
              $max_unique_overflows++ if $self->check_thresholds(value => $unique_dump->{count}, metric => 'max_unique_shortdumps');
            }
            $self->add_info(sprintf "the most frequent error appeared %d times", $max_unique_shortdumps);
            $self->add_message($self->check_thresholds(value => $max_unique_shortdumps, metric => 'max_unique_shortdumps'));
            $self->add_perfdata(
                label => 'max_unique_shortdumps',
                value => $max_unique_shortdumps
            );
          }
          if ($self->opts->report eq "html") {
            if ($self->mode =~ /server::snap::shortdumps::count/) {
              @titles = qw(datum uzeit ahost uname mandt error program);
              foreach my $shortdump (@shortdumps) {
                push(@{$table}, [map { [$shortdump->{$_}, 2] } @titles]);
              }
            } elsif ($self->mode =~ /server::snap::shortdumps::recurrence/) {
              @titles = qw(count ahost uname mandt error program);
              foreach my $unique_dump (map { 
                  $unique_dumps->{$_}
              } reverse sort {
                  $unique_dumps->{$a}->{count} <=> $unique_dumps->{$b}->{count} 
              } keys %{$unique_dumps}) {
                my $level = $self->check_thresholds(value => $num_shortdumps, metric => 'shortdumps') ?
                    $self->check_thresholds(value => $num_shortdumps, metric => 'shortdumps') :
                    $self->check_thresholds(value => $unique_dump->{count}, metric => 'max_unique_shortdumps');
                my @line = ([$unique_dump->{count}, $level]);
                push(@line, map {
                    [$unique_dump->{dump}->{$_}, $level]
                } qw(ahost uname mandt error program));
                push(@{$table}, \@line);
              }
            }
            $self->add_html($self->table_html($table, \@titles));
            my ($code, $message) = $self->check_messages();
            printf "%s - %s%s\n", $self->status_code($code), $message, $self->perfdata_string() ? " | ".$self->perfdata_string() : "";
            $self->suppress_messages();
            print $self->html_string();
            printf "\n <!--\nASCII_NOTIFICATION_START\n";
            printf "%s - %s%s\n", $self->status_code($code), $message, $self->perfdata_string() ? " | ".$self->perfdata_string() : "";
            printf "%s", $self->table_ascii($table, \@titles);
            printf "ASCII_NOTIFICATION_END\n-->\n";
          }
        }
      }
      $self->save_state( name => "to", save => {to => $now} );
    };
    if ($@) {
      $self->add_unknown($@);
    }
  }
}

package Classes::SAP::Component::UpdateSubsystem;
our @ISA = qw(GLPlugin::Item);
use strict;

sub session {
  my $self = shift;
  return $Classes::SAP::session;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /server::updates::failed/) {
    eval {
      my $now = time - 1;
      my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
          localtime($now);
      my $todate = sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
      my $totime = sprintf "%02d%02d%02d", $hour, $min, $sec;
      my $from = $self->opts->lookback ? $now - $self->opts->lookback :
          $self->load_state( name => "to" ) ? $self->load_state( name => "to" )->{to} :
          $now - 3600;
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
          localtime($from + 1);
      my $fromdate = sprintf "%04d%02d%02d", $year + 1900, $mon + 1, $mday;
      my $fromtime = sprintf "%02d%02d%02d", $hour, $min, $sec;
      my $fl = $self->session->function_lookup("RFC_READ_TABLE");
      my $fc = $fl->create_function_call;
      $fc->QUERY_TABLE("VBHDR");
      $fc->DELIMITER(";");
      my $condition = sprintf "VBDATE > '%s%s'", $fromdate, $fromtime;
      my @options = ();
      while ($condition ne "") {
        $condition =~ /(.{1,70}(\s|$))/ms;
        push(@options, {'TEXT' => $1});
        $condition = $';
      }
      $fc->OPTIONS(\@options);
      $fc->FIELDS([
          { 'FIELDNAME' => 'VBKEY' },
          { 'FIELDNAME' => 'VBREPORT' },
          { 'FIELDNAME' => 'VBENQKEY' },
          { 'FIELDNAME' => 'VBDATE' }
      ]);
      $fc->invoke;
      my @rows = @{$fc->DATA};
      my $failed_updates = scalar(@rows);
      $self->set_thresholds(warning => 10, critical => 20);
      if ($failed_updates == 0) {
        $self->add_info("no failed updates in system");
      } else {
        $self->add_info(
            sprintf "%d new failed update records appeared between %s %s and %s %s", 
            $failed_updates, $fromdate, $fromtime, $todate, $totime);
      }
      $self->add_message($self->check_thresholds($failed_updates));
      $self->add_perfdata(
          label => 'failed_updates',
          value => $failed_updates,
      );
      $self->save_state( name => "to", save => {to => $now} );
    };
    if ($@) {
      $self->add_unknown($@);
    }
  }
}

package Classes::SAP::Component::BackgroundjobSubsystem;
our @ISA = qw(GLPlugin::Item);
use strict;

sub session {
  my $self = shift;
  return $Classes::SAP::session;
}

sub init {
  my $self = shift;
  {
    no strict 'refs';
    *{'Classes::SAP::Component::BackgroundjobSubsystem::epoch_to_abap_date'} = \&{'Classes::SAP::epoch_to_abap_date'};
    *{'Classes::SAP::Component::BackgroundjobSubsystem::epoch_to_abap_time'} = \&{'Classes::SAP::epoch_to_abap_time'};
    *{'Classes::SAP::Component::BackgroundjobSubsystem::epoch_to_abap_date_and_time'} = \&{'Classes::SAP::epoch_to_abap_date_and_time'};
  }
  $self->{jobs} = [];
  eval {
    my $now = time - 1;
    my ($todate, $totime) = $self->epoch_to_abap_date_and_time($now);
    my $from = $self->opts->lookback ? $now - $self->opts->lookback :
        $self->load_state( name => "to" ) ? $self->load_state( name => "to" )->{to} :
        $now - 3600;
    my ($fromdate, $fromtime) = $self->epoch_to_abap_date_and_time($from + 1);
    my $fl = $self->session->function_lookup("RFC_READ_TABLE");
    my $fc = $fl->create_function_call;
    $fc->QUERY_TABLE("TBTCO");
    $fc->DELIMITER(";");
    my $condition = sprintf "ENDDATE >= '%s' AND ENDTIME > '%s'", $fromdate, $fromtime;
    my @options = ();
    while ($condition ne "") {
      $condition =~ /(.{1,70}(\s|$))/ms;
      push(@options, {'TEXT' => $1});
      $condition = $';
    }
    $fc->OPTIONS(\@options);
    my @fields = qw(JOBNAME SDLUNAME STRTDATE STRTTIME ENDDATE ENDTIME STATUS SDLSTRTDT SDLSTRTTM);
    $fc->FIELDS([map { { 'FIELDNAME' => $_ } } @fields]);
    $fc->invoke;
    @{$self->{jobs}} = sort {
      $a->{stop} <=> $b->{stop}
    } grep {
      $self->filter_name($_->{JOBNAME}) && $self->filter_name2($_->{SDLUNAME});
    } map {
      my %hash = ();
      my @values = split(";", $_->{WA});
      @hash{@fields} = @values;
      Job->new(%hash);
    } @{$fc->DATA};
    $self->save_state( name => "to", save => {to => $now} );
  };
  if ($@) {
    $self->add_unknown($@);
  }
}

sub check {
  my $self = shift;
  if (! $self->check_messages()) {
    if (! @{$self->{jobs}}) {
      $self->add_unknown("no finished jobs were found");
    } else {
      if ($self->mode =~ /server::backgroundjobs::list/) {
        foreach (@{$self->{jobs}}) {
          printf "%-12s %-32s %s %4d %4d %s\n", $_->{SDLUNAME}, $_->{JOBNAME},
              $_->{output_start}, $_->{runtime}, $_->{delay}, $_->{STATUS};
        }
      } else {
        my $jobs = {};
        map { $jobs->{$_->{JOBNAME}.$_->{SDLUNAME}}++ } @{$self->{jobs}};
        if ($self->mode =~ /server::backgroundjobs::(failed|runtime)/) {
          foreach (@{$self->{jobs}}) {
            $_->check() if (! $self->opts->unique || ($self->opts->unique && ! --$jobs->{$_->{JOBNAME}.$_->{SDLUNAME}}));
          }
        }
        if (! $self->check_messages()) {
          $self->add_ok("all jobs finished in time with status ok");
        }
      }
    }
  }
}

package Job;
our @ISA = qw(GLPlugin::TableItem);
use strict;
use Date::Manip::Date;

sub finish {
  my $self = shift;
  # man kann eigentlich davon ausgehen, dass jeder Job STRT* und END* hat,
  # da die Tabelle TBTCO nur beendete (mit welchem Status auch immer) Eintraege
  # enthaelt.
  foreach (keys %{$self}) {
    $self->{$_} =~ s/^\s+//;
    $self->{$_} =~ s/\s+$//;
  }
  my $date = new Date::Manip::Date;
  if ($self->{ENDDATE} && $self->{ENDTIME}) {
    $date->parse_format("%Y%m%d%H%M%S", $self->{ENDDATE}.$self->{ENDTIME});
    $self->{stop} = $date->printf("%s");
    $self->{output_stop} = $date->printf("%d.%m.%Y %H:%M:%S");
  }
  if ($self->{STRTDATE} && $self->{STRTTIME}) {
    $date->parse_format("%Y%m%d%H%M%S", $self->{STRTDATE}.$self->{STRTTIME});
    $self->{start} = $date->printf("%s");
    $self->{output_start} = $date->printf("%d.%m.%Y %H:%M:%S");
  }
  if ($self->{start} && $self->{stop}) {
    $self->{runtime} = $self->{stop} - $self->{start};
  }
  if ($self->{SDLSTRTDT} && $self->{SDLSTRTTM}) {
    $date->parse_format("%Y%m%d%H%M%S", $self->{SDLSTRTDT}.$self->{SDLSTRTTM});
    $self->{planned_start} = $date->printf("%s");
  }
  if ($self->{start} && $self->{planned_start}) {
    $self->{delay} = $self->{start} - $self->{planned_start};
  }
}

sub check {
  my $self = shift;
  if ($self->mode =~ /server::backgroundjobs::(failed|runtime)/) {
    if ($self->{STATUS} eq "A") {
      $self->add_critical(sprintf "job %s failed at %s", $self->{JOBNAME}, $self->{output_stop});
    }
  }
  if ($self->mode =~ /server::backgroundjobs::runtime/) {
    $self->set_thresholds(metric => $self->{SDLUNAME}.'_'.$self->{JOBNAME}.'_runtime',
       warning => 60, critical => 300);
    $self->add_info(sprintf "job %s of user %s ran for %ds",
        $self->{JOBNAME}, $self->{SDLUNAME}, $self->{runtime});
    if ($self->check_thresholds(metric => $self->{SDLUNAME}.'_'.$self->{JOBNAME}.'_runtime',
        value => $self->{runtime},)) {
      my ($warning, $critical) = $self->get_thresholds(
          metric => $self->{SDLUNAME}.'_'.$self->{JOBNAME}.'_runtime');
      $self->annotate_info(sprintf "limit: %ds", $self->{runtime} > $critical ?
          $critical : $warning);
      $self->add_message($self->check_thresholds(
          metric => $self->{SDLUNAME}.'_'.$self->{JOBNAME}.'_runtime',
          value => $self->{runtime},
      ));
    }
    $self->add_perfdata(
        label => $self->{SDLUNAME}.'_'.$self->{JOBNAME}.'_runtime',
        value => $self->{runtime},
        uom => 's',
    );
  }
}

package main;
# /usr/bin/perl -w

use strict;
use File::Basename;



my $plugin = Classes::Device->new(
    shortname => '',
    usage => 'Usage: %s [ -v|--verbose ] [ -t <timeout> ] '.
        '--mode <what-to-do> '.
        '--ashost <hostname> --sysnr <system number> '.
        '  ...]',
    version => '$Revision: 1.5.1.2 $',
    blurb => 'This plugin checks sap netweaver ',
    url => 'http://labs.consol.de/nagios/check_sap_health',
    timeout => 60,
    plugin => basename($0),
);
$plugin->add_mode(
    internal => 'device::uptime',
    spec => 'uptime',
    alias => undef,
    help => 'Check the uptime of the device',
);

$plugin->add_mode(
    internal => 'server::connectiontime',
    spec => 'connection-time',
    alias => undef,
    help => 'Time to connect to the server',
);
$plugin->add_mode(
    internal => 'server::connectiontime::sapinfo',
    spec => 'sapinfo',
    alias => undef,
    help => 'Time to connect and show system atttributes like sapinfo',
);
$plugin->add_mode(
    internal => 'server::ccms::moniset::list',
    spec => 'list-ccms-monitor-sets',
    alias => undef,
    help => 'List all available monitor sets',
);
$plugin->add_mode(
    internal => 'server::ccms::monitor::list',
    spec => 'list-ccms-monitors',
    alias => undef,
    help => 'List all monitors (can be restricted to a monitor set with --name)',
);
$plugin->add_mode(
    internal => 'server::ccms::mte::list',
    spec => 'list-ccms-mtes',
    alias => undef,
    help => 'List all MTEs (must be restricted to a monitor set / monitor with --name/--name2)',
);
$plugin->add_mode(
    internal => 'server::ccms::mte::check',
    spec => 'ccms-mte-check',
    alias => undef,
    help => 'Check all MTEs (must be restricted to a monitor set / monitor with --name/--name2)',
);
$plugin->add_mode(
    internal => 'server::snap::shortdumps::list',
    spec => 'shortdumps-list',
    alias => undef,
    help => 'Read the SNAP table and list the short dumps',
);
$plugin->add_mode(
    internal => 'server::snap::shortdumps::count',
    spec => 'shortdumps-count',
    alias => undef,
    help => 'Read the SNAP table and count the short dumps (can be restricted with --name/--name2 = username/program)',
);
$plugin->add_mode(
    internal => 'server::snap::shortdumps::recurrence',
    spec => 'shortdumps-recurrence',
    alias => undef,
    help => 'Like shortdumps-count, but counts the recurrence of the same errors',
);
$plugin->add_mode(
    internal => 'server::updates::failed',
    spec => 'failed-updates',
    alias => undef,
    help => 'Counts new entries in the VHDR table (since last run or appeared in the interval specified by --lookback)',
);
$plugin->add_mode(
    internal => 'server::backgroundjobs::failed',
    spec => 'failed-jobs',
    alias => undef,
    help => 'Looks for failed jobs in the TBTCO table (since last run or in the interval specified by --lookback)',
);
$plugin->add_mode(
    internal => 'server::backgroundjobs::runtime',
    spec => 'exceeded-failed-jobs',
    alias => undef,
    help => 'Looks for jobs in the TBTCO table which failed or exceeded a certain runtime (since last run or in the interval specified by --lookback)',
);
$plugin->add_mode(
    internal => 'server::snap::list',
    spec => 'list-shortdumps',
    alias => undef,
    help => 'Read the SNAP table and list the short dumps',
);
$plugin->add_mode(
    internal => 'server::backgroundjobs::list',
    spec => 'list-jobs',
    alias => undef,
    help => 'Read the TBTCO table and list the jobs',
);
$plugin->add_arg(
    spec => 'ashost|H=s',
    help => '--ashost
   Hostname or IP-address of the application server',
    required => 0,
);
$plugin->add_arg(
    spec => 'sysnr=s',
    help => '--sysnr
   The system number',
    required => 0,
);
$plugin->add_arg(
    spec => 'mshost=s',
    help => '--mshost
   Hostname or IP-address of the message server',
    required => 0,
);
$plugin->add_arg(
    spec => 'msserv=s',
    help => '--msserv
   The port for mshost connections',
    required => 0,
);
$plugin->add_arg(
    spec => 'r3name=s',
    help => '--r3name
   The SID for mshost connections',
    required => 0,
);
$plugin->add_arg(
    spec => 'group=s',
    help => '--group
   The logon group for mshost connections',
    required => 0,
);
$plugin->add_arg(
    spec => 'gwhost=s',
    help => '--gwhost
   The gateway host',
    required => 0,
);
$plugin->add_arg(
    spec => 'gwserv=s',
    help => '--gwserv
   The gateway port',
    required => 0,
);
$plugin->add_arg(
    spec => 'username=s',
    help => '--username
   The username',
    required => 0,
);
$plugin->add_arg(
    spec => 'password=s',
    help => '--password
   The password',
    required => 0,
);
$plugin->add_arg(
    spec => 'client=s',
    help => '--client
   The client',
    default => '001',
    required => 0,
);
$plugin->add_arg(
    spec => 'lang=s',
    help => '--lang
   The language',
    default => 'EN',
    required => 0,
);
$plugin->add_arg(
    spec => 'mode=s',
    help => "--mode
   A keyword which tells the plugin what to do",
    required => 1,
);
$plugin->add_arg(
    spec => 'report=s',
    help => "--report
   Can be used to shorten the output",
    required => 0,
    default => 'long',
);
$plugin->add_arg(
    spec => 'lookback=s',
    help => "--lookback
   The amount of time you want to look back when calculating average rates.
   Use it for mode interface-errors or interface-usage. Without --lookback
   the time between two runs of check_nwc_health is the base for calculations.
   If you want your checkresult to be based for example on the past hour,
   use --lookback 3600. ",
    required => 0,
);
$plugin->add_arg(
    spec => 'warning=s',
    help => '--warning
   The warning threshold',
    required => 0,
);
$plugin->add_arg(
    spec => 'critical=s',
    help => '--critical
   The critical threshold',
    required => 0,
);

$plugin->add_arg(
    spec => 'name=s',
    help => "--name
   The name of whatever",
    required => 0,
);
$plugin->add_arg(
    spec => 'drecksptkdb=s',
    help => "--drecksptkdb
   This parameter must be used instead of --name, because Devel::ptkdb is stealing the latter from the command line",
    aliasfor => "name",
    required => 0,
);
$plugin->add_arg(
    spec => 'name2=s',
    help => "--name2
   The secondary name of whatever",
    required => 0,
);
$plugin->add_arg(
    spec => 'name3=s',
    help => "--name3
   The tertiary name of whatever",
    required => 0,
);
$plugin->add_arg(
    spec => 'regexp',
    help => "--regexp
   Parameter name/name2/name3 will be interpreted as (perl) regular expression",
    required => 0,
);
$plugin->add_arg(
    spec => 'separator=s',
    help => "--separator
   A separator for MTE path elements",
    required => 0,
);
$plugin->add_arg(
    spec => 'warningx=s%',
    help => '--warningx
   The extended warning thresholds',
    required => 0,
);
$plugin->add_arg(
    spec => 'criticalx=s%',
    help => '--criticalx
   The extended critical thresholds',
    required => 0,
);
$plugin->add_arg(
    spec => 'mitigation=s',
    help => "--mitigation
   The parameter allows you to change a critical error to a warning.",
    required => 0,
);
$plugin->add_arg(
    spec => 'unique',
    help => "--unique
   The parameter limits the output to unique (or only the last) items.",
    required => 0,
);
$plugin->add_arg(
    spec => 'selectedperfdata=s',
    help => "--selectedperfdata
   The parameter allows you to limit the list of performance data. It's a perl regexp.
   Only matching perfdata show up in the output",
    required => 0,
);
$plugin->add_arg(
    spec => 'negate=s%',
    help => "--negate
   The parameter allows you to map exit levels, such as warning=critical",
    required => 0,
);
$plugin->add_arg(
    spec => 'with-mymodules-dyn-dir=s',
    help => '--with-mymodules-dyn-dir
   A directory where own extensions can be found',
    required => 0,
);
$plugin->add_arg(
    spec => 'statefilesdir=s',
    help => '--statefilesdir
   An alternate directory where the plugin can save files',
    required => 0,
);
$plugin->add_arg(
    spec => 'multiline',
    help => '--multiline
   Multiline output',
    required => 0,
);

$plugin->getopts();
$plugin->classify();
$plugin->validate_args();


if (! $plugin->check_messages()) {
  $plugin->init();
  if (! $plugin->check_messages()) {
    $plugin->add_ok($plugin->get_summary())
        if $plugin->get_summary();
    $plugin->add_ok($plugin->get_extendedinfo(" "))
        if $plugin->get_extendedinfo();
  }
} else {
  $plugin->add_critical('wrong device');
}
my ($code, $message) = $plugin->opts->multiline ?
    $plugin->check_messages(join => "\n", join_all => ', ') :
    $plugin->check_messages(join => ', ', join_all => ', ');
$message .= sprintf "\n%s\n", $plugin->get_info("\n")
    if $plugin->opts->verbose >= 1;
#printf "%s\n", Data::Dumper::Dumper($plugin);
$plugin->nagios_exit($code, $message);


